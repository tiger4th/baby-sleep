<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ベビースリープ予測</title>
<link rel="manifest" href="./manifest.json">
<style>
body { font-family: sans-serif; padding: 10px; background: #f5f5f5; }
h1 { font-size: 1.4em; }
button { margin: 5px; padding: 10px; font-size: 1em; }
#log, #prediction { margin-top: 10px; background: white; padding: 10px; border-radius: 6px; }
canvas { background: white; margin-top: 15px; border-radius: 6px; }
</style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js?v=20250810-1"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.umd.min.js?v=20250810-1"></script>
</head>
<body>

<h1>ベビースリープ予測</h1>
<div>
  <button onclick="addLog('wake')">起きた</button>
  <button onclick="addLog('nap')">寝た</button>
</div>
  
  <div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
    <b>時間指定で追加／編集</b><br>
    <select id="typeSelect">
      <option value="wake">起きた</option>
      <option value="nap">寝た</option>
    </select>
    <input id="timeInput" type="time" step="60">
    <button id="addBtn" onclick="handleAddOrUpdate()">この時間で追加</button>
    <button id="cancelEditBtn" onclick="cancelEdit()" style="display:none;">キャンセル</button>
    <span id="editStatus" style="margin-left:8px;color:#666;"></span>
  </div>

  <div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
    <b>生年月日</b><br>
    <input id="birthInput" type="date">
    <button onclick="saveBirth()">保存</button>
    <span id="birthStatus" style="margin-left:8px;color:#666;"></span>
  </div>

  <div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
    <b>表示日</b><br>
    <input id="viewDate" type="date">
    <button onclick="goToday()">今日</button>
    <button onclick="shiftDay(-1)">前日</button>
    <button onclick="shiftDay(1)">翌日</button>
    <span id="viewDateStatus" style="margin-left:8px;color:#666;"></span>
  </div>

<div id="log"></div>
<div id="prediction"></div>
<canvas id="timelineChart" height="150"></canvas>

<div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
  <b>ぴよログからインポート</b><br>
  <input id="piyoFile" type="file" accept=".txt">
  <button onclick="handleImportPiyolog()">インポート</button>
  <span id="importStatus" style="margin-left:8px;color:#666;"></span>
  <div style="color:#888; font-size:0.9em; margin-top:6px;">
    ファイルに含まれる全ての日の「起きる／寝る」を取り込みます（同日の既存記録は上書き）。
  </div>
</div>

<div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
  <b>CSVエクスポート</b><br>
  <button onclick="exportSleepData()">睡眠データをエクスポート</button>
  <span id="analysisStatus" style="margin-left:8px;color:#666;"></span>
</div>

<script>
// データ構造を日付ごとの辞書に移行（互換: 旧配列→今日の日付に移行）
let allLogsRaw = null;
try {
  allLogsRaw = JSON.parse(localStorage.getItem('babyLogs') || 'null');
} catch (_) {
  allLogsRaw = null;
}

function __computeTodayKey() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}/${m}/${day}`;
}

let allLogs = {};
if (Array.isArray(allLogsRaw)) {
  // 旧形式（配列）→ 今日の日付に移し替え
  const todayKey = __computeTodayKey();
  allLogs[todayKey] = allLogsRaw.filter(l => l && (l.type === 'wake' || l.type === 'nap'));
} else if (allLogsRaw && typeof allLogsRaw === 'object') {
  allLogs = allLogsRaw;
  // 各日ごとに型フィルタを適用
  for (const k of Object.keys(allLogs)) {
    const arr = Array.isArray(allLogs[k]) ? allLogs[k] : [];
    allLogs[k] = arr.filter(l => l && (l.type === 'wake' || l.type === 'nap'));
  }
} else {
  const todayKey = __computeTodayKey();
  allLogs[todayKey] = [];
}
localStorage.setItem('babyLogs', JSON.stringify(allLogs));

let currentDateKey = __computeTodayKey();
let logs = allLogs[currentDateKey] || [];
let timelineChart = null;
let editingIndex = null;
const BIRTH_KEY = "babyBirthDate"; // YYYY-MM-DD で保存

function nowTimeString() {
  const now = new Date();
  const hh = String(now.getHours()).padStart(2, '0');
  const mm = String(now.getMinutes()).padStart(2, '0');
  return `${hh}:${mm}`;
}

function getSortKey(timeStr) {
  const [h, m] = timeStr.split(":").map(Number);
  // 07:00を日境界にし、<07:00 は翌日扱い
  const minutes = h * 60 + m;
  return minutes < 7 * 60 ? minutes + 24 * 60 : minutes;
}

function sortLogs() {
  logs.sort((a, b) => getSortKey(a.time) - getSortKey(b.time));
}

function saveAllLogs() {
  localStorage.setItem('babyLogs', JSON.stringify(allLogs));
}

function setCurrentDateKey(newKey) {
  currentDateKey = newKey;
  if (!allLogs[currentDateKey]) allLogs[currentDateKey] = [];
  // 型フィルタ
  allLogs[currentDateKey] = allLogs[currentDateKey].filter(l => l && (l.type === 'wake' || l.type === 'nap'));
  logs = allLogs[currentDateKey];
  sortLogs();
  saveAllLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  updateViewDateStatus();
  // 予測精度統計を更新
  showPredictionStats();
}

function keyFromInputValue(value) { // YYYY-MM-DD -> YYYY/MM/DD
  if (!value) return null;
  const [y, m, d] = value.split('-');
  return `${y}/${m}/${d}`;
}

function inputValueFromKey(key) { // YYYY/MM/DD -> YYYY-MM-DD
  if (!key) return '';
  const [y, m, d] = key.split('/');
  return `${y}-${m}-${d}`;
}

function goToday() {
  setCurrentDateKey(__computeTodayKey());
  const viewDateEl = document.getElementById('viewDate');
  if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);
}

function shiftDay(delta) {
  const [y, m, d] = currentDateKey.split('/').map(Number);
  const dt = new Date(y, m - 1, d);
  dt.setDate(dt.getDate() + delta);
  const key = `${dt.getFullYear()}/${String(dt.getMonth() + 1).padStart(2, '0')}/${String(dt.getDate()).padStart(2, '0')}`;
  setCurrentDateKey(key);
  const viewDateEl = document.getElementById('viewDate');
  if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);
}

function updateViewDateStatus() {
  const status = document.getElementById('viewDateStatus');
  if (!status) return;
  status.textContent = `表示中: ${currentDateKey}（${logs.length}件）`;
}

function addLog(type) {
  const time = nowTimeString();
  addLogAt(type, time);
}

function addLogAt(type, time) {
  if (!time || !/^\d{2}:\d{2}$/.test(time)) {
    alert('時刻は HH:MM 形式で指定してください');
    return;
  }
  if (!(type === 'wake' || type === 'nap')) {
    alert('追加できるのは「起きた」「寝た」のみです');
    return;
  }
  logs.push({ type, time });
  sortLogs();
  allLogs[currentDateKey] = logs;
  saveAllLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  // 予測精度統計を更新
  showPredictionStats();
}

function startEditLog(index) {
  const target = logs[index];
  if (!target) return;
  editingIndex = index;
  document.getElementById('typeSelect').value = target.type;
  document.getElementById('timeInput').value = target.time;
  const addBtn = document.getElementById('addBtn');
  addBtn.textContent = '更新';
  document.getElementById('cancelEditBtn').style.display = '';
  document.getElementById('editStatus').textContent = `編集中: ${target.time} - ${translateType(target.type)}`;
}

function handleAddOrUpdate() {
  const type = document.getElementById('typeSelect').value;
  const time = document.getElementById('timeInput').value;
  if (!time || !/^\d{2}:\d{2}$/.test(time)) {
    alert('時刻は HH:MM 形式で指定してください');
    return;
  }
  if (editingIndex === null) {
    addLogAt(type, time);
  } else {
    logs[editingIndex] = { type, time };
    sortLogs();
    allLogs[currentDateKey] = logs;
    saveAllLogs();
    renderLogs();
    updateTimelineChart();
    updatePrediction();
    // 予測精度統計を更新
    showPredictionStats();
    cancelEdit();
  }
}

function cancelEdit() {
  editingIndex = null;
  const addBtn = document.getElementById('addBtn');
  addBtn.textContent = 'この時間で追加';
  document.getElementById('cancelEditBtn').style.display = 'none';
  document.getElementById('editStatus').textContent = '';
  const timeInputEl = document.getElementById('timeInput');
  if (timeInputEl) timeInputEl.value = nowTimeString();
}

function deleteLog(index) {
  const target = logs[index];
  if (!target) return;
  const ok = confirm(`削除しますか？\n${target.time} - ${translateType(target.type)}`);
  if (!ok) return;
  logs.splice(index, 1);
  allLogs[currentDateKey] = logs;
  saveAllLogs();
  sortLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  // 予測精度統計を更新
  showPredictionStats();
  cancelEdit();
}

function renderLogs() {
  const container = document.getElementById("log");
  const total = logs.length;
  const recentCount = 3;
  const header = "<b>記録</b><br>";

  if (total <= recentCount) {
    const allHtml = logs.map((l, i) => {
      return `${l.time} - ${translateType(l.type)} ` +
        `<button onclick="startEditLog(${i})">編集</button> ` +
        `<button onclick="deleteLog(${i})">削除</button>`;
    }).join("<br>");
    container.innerHTML = header + allHtml;
    return;
  }

  const olderCount = total - recentCount;
  const recentBaseIndex = total - recentCount;

  const olderHtml = logs.slice(0, olderCount).map((l, i) => {
    const idx = i; // 先頭からのインデックスはそのまま
    return `${l.time} - ${translateType(l.type)} ` +
      `<button onclick="startEditLog(${idx})">編集</button> ` +
      `<button onclick="deleteLog(${idx})">削除</button>`;
  }).join("<br>");

  const recentHtml = logs.slice(recentBaseIndex).map((l, i) => {
    const idx = recentBaseIndex + i; // 元配列でのインデックス
    return `${l.time} - ${translateType(l.type)} ` +
      `<button onclick="startEditLog(${idx})">編集</button> ` +
      `<button onclick="deleteLog(${idx})">削除</button>`;
  }).join("<br>");

  const detailsHtml =
    `<details>` +
      `<summary>過去の記録を表示（${olderCount}件）</summary>` +
      `${olderHtml ? `<div style="margin-top:8px;">${olderHtml}</div>` : ""}` +
    `</details>`;

  // 昇順の表示順を維持するため、先に折りたたみ、その後に直近3件を表示
  container.innerHTML = header + detailsHtml + "<br>" + recentHtml;
}

function translateType(type) {
  return type === "wake" ? "起きた" :
         type === "nap" ? "寝た" : type;
}

// 生年月日の保存・読込と月齢ベースの推定
function saveBirth(showSavedMessage = true) {
  const input = document.getElementById('birthInput');
  const status = document.getElementById('birthStatus');
  if (!input || !status) return;
  const value = input.value; // YYYY-MM-DD or ''
  if (!value) {
    localStorage.removeItem(BIRTH_KEY);
    status.textContent = '未設定';
    updatePrediction();
    return;
  }
  // 簡易バリデーション
  if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) {
    status.textContent = '日付形式が不正です (YYYY-MM-DD)';
    return;
  }
  localStorage.setItem(BIRTH_KEY, value);
  const birth = loadBirth();
  const months = birth ? calculateMonthsAge(birth) : null;
  status.textContent = months !== null ? `保存しました（月齢: ${months}ヶ月）` : '保存しました';
  if (!showSavedMessage) {
    // 即時保存時は控えめな表示
    status.textContent = months !== null ? `保存済み（月齢: ${months}ヶ月）` : '保存済み';
  }
  updatePrediction();
}

function loadBirth() {
  const stored = localStorage.getItem(BIRTH_KEY);
  if (!stored) return null;
  // Local 00:00 に設定
  const [y, m, d] = stored.split('-').map(Number);
  const dt = new Date();
  dt.setHours(0, 0, 0, 0);
  dt.setFullYear(y, m - 1, d);
  return isNaN(dt.getTime()) ? null : dt;
}

function calculateMonthsAge(birthDate, refDate = new Date()) {
  if (!birthDate) return null;
  const y1 = birthDate.getFullYear();
  const m1 = birthDate.getMonth();
  const d1 = birthDate.getDate();
  const y2 = refDate.getFullYear();
  const m2 = refDate.getMonth();
  const d2 = refDate.getDate();
  let months = (y2 - y1) * 12 + (m2 - m1);
  if (d2 < d1) months -= 1; // 当月の誕生日未到達なら-1
  return Math.max(0, months);
}

function getAwakeWindowByMonths(monthsAge) {
  // 参考レンジ（分）: 文献や一般的な目安に基づく緩めの範囲
  if (monthsAge === null) return [120, 150];
  if (monthsAge <= 2) return [45, 90];
  if (monthsAge <= 4) return [75, 120];
  if (monthsAge <= 6) return [90, 150];
  if (monthsAge <= 8) return [120, 180];
  if (monthsAge <= 10) return [150, 210];
  if (monthsAge <= 12) return [180, 240];
  return [210, 300];
}

function getNapLengthByMonths(monthsAge, nextNapStart) {
  const hour = nextNapStart.getHours();
  // 基本レンジ（分）
  let minMax;
  if (monthsAge === null) {
    minMax = [60, 90];
  } else if (monthsAge <= 2) {
    minMax = [60, 120];
  } else if (monthsAge <= 4) {
    minMax = [60, 120];
  } else if (monthsAge <= 6) {
    minMax = [60, 90];
  } else if (monthsAge <= 8) {
    minMax = [45, 90];
  } else if (monthsAge <= 12) {
    minMax = [45, 90];
  } else {
    minMax = [45, 60];
  }
  let nap = randomIntInclusive(minMax[0], minMax[1]);
  // 15時以降は短めに制限
  if (hour >= 15) {
    nap = Math.min(nap, 45);
  }
  return nap;
}

function randomIntInclusive(min, max) {
  const mn = Math.ceil(min);
  const mx = Math.floor(max);
  return Math.floor(Math.random() * (mx - mn + 1)) + mn;
}

function updatePrediction() {
  if (logs.length === 0) {
    document.getElementById("prediction").innerHTML = "この日の起床ログ後に予測が表示されます。";
    return;
  }
  // 直近の「状態」ログ（wake/nap）のみを見る。
  const lastStateIndex = [...logs].map((l, i) => ({...l, i}))
    .filter(l => l.type === 'wake' || l.type === 'nap')
    .map(l => l.i)
    .pop();
  if (lastStateIndex === undefined) {
    document.getElementById("prediction").innerHTML = "この日の起床ログ後に予測が表示されます。";
    return;
  }
  const lastState = logs[lastStateIndex];
  if (lastState.type !== 'wake') {
    document.getElementById("prediction").innerHTML = "この日の起床ログ後に予測が表示されます。";
    return;
  }

  const [h, m] = lastState.time.split(":").map(Number);
  const wakeTime = new Date();
  wakeTime.setHours(h, m);

  const birthDate = loadBirth();
  const monthsAge = birthDate ? calculateMonthsAge(birthDate, new Date()) : null;

  // 過去データベースの予測を取得
  const historicalPrediction = getHistoricalPrediction(wakeTime, monthsAge);
  
  // 月齢ベースの基本予測
  const [awakeMin, awakeMax] = getAwakeWindowByMonths(monthsAge);
  const basicAwakeMinutes = randomIntInclusive(awakeMin, awakeMax);
  const basicNextNapStart = new Date(wakeTime.getTime() + basicAwakeMinutes * 60000);
  const basicNapLengthMinutes = getNapLengthByMonths(monthsAge, basicNextNapStart);

  // 過去データと基本予測を組み合わせた最終予測
  let finalAwakeMinutes, finalNapLengthMinutes;
  if (historicalPrediction) {
    // 過去データがある場合は、基本予測と過去データを重み付けで組み合わせ
    const historicalWeight = 0.7; // 過去データの重み
    const basicWeight = 0.3; // 基本予測の重み
    
    finalAwakeMinutes = Math.round(
      historicalPrediction.avgAwakeTime * historicalWeight + 
      basicAwakeMinutes * basicWeight
    );
    finalNapLengthMinutes = Math.round(
      historicalPrediction.avgNapLength * historicalWeight + 
      basicNapLengthMinutes * basicWeight
    );
  } else {
    // 過去データがない場合は基本予測を使用
    finalAwakeMinutes = basicAwakeMinutes;
    finalNapLengthMinutes = basicNapLengthMinutes;
  }

  const nextNapStart = new Date(wakeTime.getTime() + finalAwakeMinutes * 60000);
  const wakeUpTime = new Date(nextNapStart.getTime() + finalNapLengthMinutes * 60000);

  const monthsInfo = monthsAge !== null ? `（月齢: ${monthsAge}ヶ月）` : "";
  const historicalInfo = historicalPrediction ? 
    `<br><small style="color:#666;">過去データベース: 覚醒時間 ${Math.round(historicalPrediction.avgAwakeTime)}分、睡眠時間 ${Math.round(historicalPrediction.avgNapLength)}分</small>` : "";

  document.getElementById("prediction").innerHTML =
    `<b>次の寝かしつけ目安</b>${monthsInfo}<br>
     ${formatTime(nextNapStart)}ごろベッドに<br>
     <b>入眠予測</b> ${formatTime(new Date(nextNapStart.getTime() + 5*60000))}<br>
     <b>起床予測</b> ${formatTime(wakeUpTime)}
     ${historicalInfo}`;
}

function formatTime(date) {
  return date.toTimeString().slice(0,5);
}

function updateTimelineChart() {
  const isDateAdapterReady = () => {
    const a = Chart && Chart._adapters && Chart._adapters._date;
    return !!(a && a.format && a.parse && a.add && a.diff && a.startOf && a.endOf && a.formats);
  };
  // 表示日の 07:00 を軸
  const [y, m, d] = currentDateKey.split('/').map(Number);
  const baseStart = new Date(y, m - 1, d, 7, 0, 0, 0);
  const baseStartMs = baseStart.getTime();
  const rangeDays = 7; // 常に1週間表示

  // 週表示: 各日を縦に並べ、X軸は24時間（7:00→翌7:00）で揃える
  const dayLabels = [];
  const awakeData = [];
  const sleepData = [];

  const labelForDate = (dt) => {
    const w = ['日','月','火','水','木','金','土'];
    return `${String(dt.getMonth()+1).padStart(2,'0')}/${String(dt.getDate()).padStart(2,'0')}(${w[dt.getDay()]})`;
  };

  const generateDayEvents = (dt) => {
    const dayStart = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), 7, 0, 0, 0);
    const dayStartMs = dayStart.getTime();
    const dayEndMs = dayStartMs + 24 * 3600000;

    // 前日/当日/翌日のログからシーケンスを作成
    const seq = [];
    for (const off of [-1, 0, 1]) {
      const t = new Date(dt);
      t.setDate(t.getDate() + off);
      const key = `${t.getFullYear()}/${String(t.getMonth()+1).padStart(2,'0')}/${String(t.getDate()).padStart(2,'0')}`;
      const arr = (allLogs[key] || []).filter(l => l.type === 'wake' || l.type === 'nap')
        .sort((a,b)=>getSortKey(a.time)-getSortKey(b.time));
      for (const l of arr) {
        const [hh, mm] = l.time.split(':').map(Number);
        const base = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 7, 0, 0, 0);
        const abs = new Date(base);
        if (hh < 7) abs.setDate(abs.getDate() + 1);
        abs.setHours(hh, mm, 0, 0);
        seq.push({ type: l.type, date: abs });
      }
    }
    seq.sort((a,b)=>a.date.getTime()-b.date.getTime());

    // 連続ペアから当日ウィンドウにクリップしてイベント化
    const evs = [];
    for (let i = 0; i < seq.length - 1; i++) {
      let start = seq[i].date.getTime();
      let end = seq[i+1].date.getTime();
      if (end <= dayStartMs || start >= dayEndMs) continue;
      if (start < dayStartMs) start = dayStartMs;
      if (end > dayEndMs) end = dayEndMs;
      const label = seq[i].type === 'nap' ? '睡眠' : '覚醒';
      const color = seq[i].type === 'nap' ? '#4CAF50' : '#FF9800';
      evs.push({ label, start: new Date(start), end: new Date(end), color, dayStartMs });
    }
    return { evs, dayStartMs };
  };

  for (let i = 0; i < rangeDays; i++) {
    const dt = new Date(y, m - 1, d);
    dt.setDate(dt.getDate() + i);
    const dayLabel = rangeDays === 1 ? 'スケジュール' : labelForDate(dt);
    if (rangeDays > 1) dayLabels.push(dayLabel);

    const { evs, dayStartMs } = generateDayEvents(dt);
    for (const ev of evs) {
      // 週表示では全日のX軸を同じ24hに揃えるため、基準日の 7:00 を0としてオフセット化
      const offsetStart = ev.start.getTime() - dayStartMs;
      const offsetEnd = ev.end.getTime() - dayStartMs;
      const plotStart = new Date(baseStartMs + offsetStart);
      const plotEnd = new Date(baseStartMs + offsetEnd);
      const dataPoint = { x: [plotStart.getTime(), plotEnd.getTime()], y: dayLabel };
      if (ev.label === '睡眠') sleepData.push(dataPoint); else awakeData.push(dataPoint);
    }
  }

  // 週・日ウィンドウは seq からのイベント生成で全てカバーするため、
  // 追加の持ち越し/翌日延長ロジックは不要。

  const ctx = document.getElementById('timelineChart').getContext('2d');
  if (timelineChart) timelineChart.destroy();

  // 常に1週間表示に固定

  const baseConfig = {
    type: 'bar',
    data: {
      labels: dayLabels,
      datasets: [
        {
          label: '起床中',
          data: awakeData,
          backgroundColor: '#FF9800',
          borderSkipped: false,
          barPercentage: 0.9,
          categoryPercentage: 1.0,
          grouped: false
        },
        {
          label: '睡眠中',
          data: sleepData,
          backgroundColor: '#4CAF50',
          borderSkipped: false,
          barPercentage: 0.9,
          categoryPercentage: 1.0,
          grouped: false
        }
      ]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      plugins: { legend: { display: true } },
      scales: { x: {} }
    }
  };

  const windowStart = baseStartMs;
  const windowEnd = baseStartMs + 24 * 3600000;
  const timeseriesX = {
    type: 'timeseries',
    time: { unit: 'hour', displayFormats: { hour: 'HH:mm' } },
    min: new Date(windowStart),
    max: new Date(windowEnd)
  };
  const linearX = {
    type: 'linear',
    min: windowStart,
    max: windowEnd,
    ticks: { callback: (value) => formatTime(new Date(value)) }
  };

  try {
    baseConfig.options.scales.x = isDateAdapterReady() ? timeseriesX : linearX;
    timelineChart = new Chart(ctx, baseConfig);
  } catch (err) {
    console.warn('Chart init failed, fallback to linear scale:', err);
    baseConfig.options.scales.x = linearX;
    timelineChart = new Chart(ctx, baseConfig);
  }
}

// ぴよログ取り込み
function handleImportPiyolog() {
  const input = document.getElementById('piyoFile');
  const status = document.getElementById('importStatus');
  if (!input || !input.files || input.files.length === 0) {
    status.textContent = 'ファイルを選択してください';
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const text = String(reader.result || '');
      const parsed = parsePiyologTextMulti(text);
      const keys = Object.keys(parsed);
      if (keys.length === 0) {
        status.textContent = '取り込める記録が見つかりませんでした';
        return;
      }
      // 各日を上書き保存
      for (const k of keys) {
        const items = parsed[k].filter(l => l && (l.type === 'wake' || l.type === 'nap'));
        allLogs[k] = items;
      }
      saveAllLogs();
      // 最終日のキーに移動
      const latestKey = keys.sort((a, b) => parseDateKey(a) - parseDateKey(b))[keys.length - 1];
      setCurrentDateKey(latestKey);
      status.textContent = `インポート完了（${keys.length}日 / 最終日: ${latestKey}）`;
    } catch (e) {
      console.error(e);
      status.textContent = 'インポート中にエラーが発生しました';
    }
  };
  reader.onerror = () => {
    status.textContent = 'ファイルの読み込みに失敗しました';
  };
  reader.readAsText(file, 'utf-8');
}

function parsePiyologText(text) {
  const lines = text.split(/\r?\n/);
  const dateHeaderRegex = /^\s*(\d{4})\/(\d{1,2})\/(\d{1,2})\s*\(/;
  const timeLineRegex = /^\s*(\d{2}):(\d{2})\s+(.+)/;

  /** @type {Record<string, Array<{time: string, type: 'wake'|'nap'}>>} */
  const dateToItems = {};
  let currentDateKey = null;

  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const dh = dateHeaderRegex.exec(line);
    if (dh) {
      const y = dh[1].padStart(4, '0');
      const m = dh[2].padStart(2, '0');
      const d = dh[3].padStart(2, '0');
      currentDateKey = `${y}/${m}/${d}`;
      if (!dateToItems[currentDateKey]) dateToItems[currentDateKey] = [];
      continue;
    }
    if (!currentDateKey) continue;
    const tl = timeLineRegex.exec(line);
    if (!tl) continue;
    const hh = tl[1];
    const mm = tl[2];
    const body = tl[3];
    const time = `${hh}:${mm}`;
    let type = null;
    if (body.startsWith('起きる')) type = 'wake';
    else if (body.startsWith('寝る')) type = 'nap';
    if (type) {
      dateToItems[currentDateKey].push({ time, type });
    }
  }

  const keys = Object.keys(dateToItems);
  if (keys.length === 0) return { dateKey: null, items: [] };
  const latestKey = keys.sort((a, b) => parseDateKey(a) - parseDateKey(b))[keys.length - 1];
  return { dateKey: latestKey, items: dateToItems[latestKey] };
}

function parseDateKey(key) {
  // key: YYYY/MM/DD
  const [y, m, d] = key.split('/').map(Number);
  const dt = new Date();
  dt.setHours(0, 0, 0, 0);
  dt.setFullYear(y, m - 1, d);
  return dt.getTime();
}

// 複数日を返す版
function parsePiyologTextMulti(text) {
  const lines = text.split(/\r?\n/);
  const dateHeaderRegex = /^\s*(\d{4})\/(\d{1,2})\/(\d{1,2})\s*\(/;
  const timeLineRegex = /^\s*(\d{2}):(\d{2})\s+(.+)/;
  /** @type {Record<string, Array<{time: string, type: 'wake'|'nap'}>>} */
  const dateToItems = {};
  let currentDateKey = null;
  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const dh = dateHeaderRegex.exec(line);
    if (dh) {
      const y = dh[1].padStart(4, '0');
      const m = dh[2].padStart(2, '0');
      const d = dh[3].padStart(2, '0');
      currentDateKey = `${y}/${m}/${d}`;
      if (!dateToItems[currentDateKey]) dateToItems[currentDateKey] = [];
      continue;
    }
    if (!currentDateKey) continue;
    const tl = timeLineRegex.exec(line);
    if (!tl) continue;
    const hh = tl[1];
    const mm = tl[2];
    const body = tl[3];
    const time = `${hh}:${mm}`;
    let type = null;
    if (body.startsWith('起きる')) type = 'wake';
    else if (body.startsWith('寝る')) type = 'nap';
    if (type) {
      dateToItems[currentDateKey].push({ time, type });
    }
  }
  return dateToItems;
}

// 過去データベースの予測を取得する関数
function getHistoricalPrediction(currentWakeTime, monthsAge) {
  const allDates = Object.keys(allLogs).sort();
  if (allDates.length < 3) return null; // 最低3日分のデータが必要

  const currentDate = new Date();
  const currentHour = currentWakeTime.getHours();
  
  // 過去30日分のデータを分析
  const analysisDays = 30;
  const recentDates = allDates.slice(-analysisDays);
  
  let totalAwakeTime = 0;
  let totalNapLength = 0;
  let validPatterns = 0;

  for (const dateKey of recentDates) {
    const dayLogs = allLogs[dateKey] || [];
    if (dayLogs.length < 2) continue;

    // その日の睡眠パターンを分析
    const patterns = analyzeDayPattern(dayLogs, dateKey);
    if (patterns.length === 0) continue;

    // 現在時刻に近い時間帯のパターンを探す
    for (const pattern of patterns) {
      if (pattern.wakeHour >= currentHour - 2 && pattern.wakeHour <= currentHour + 2) {
        totalAwakeTime += pattern.awakeTime;
        totalNapLength += pattern.napLength;
        validPatterns++;
      }
    }
  }

  if (validPatterns < 2) return null; // 最低2パターンのデータが必要

  return {
    avgAwakeTime: totalAwakeTime / validPatterns,
    avgNapLength: totalNapLength / validPatterns,
    dataPoints: validPatterns
  };
}

// 1日の睡眠パターンを分析する関数
function analyzeDayPattern(dayLogs, dateKey) {
  const patterns = [];
  const sortedLogs = dayLogs
    .filter(l => l.type === 'wake' || l.type === 'nap')
    .sort((a, b) => getSortKey(a.time) - getSortKey(b.time));

  for (let i = 0; i < sortedLogs.length - 1; i++) {
    const current = sortedLogs[i];
    const next = sortedLogs[i + 1];
    
    if (current.type === 'wake' && next.type === 'nap') {
      // 起床→睡眠のパターン
      const [wakeHour, wakeMin] = current.time.split(':').map(Number);
      const [napHour, napMin] = next.time.split(':').map(Number);
      
      // 覚醒時間を計算
      let awakeTime = (napHour * 60 + napMin) - (wakeHour * 60 + wakeMin);
      if (awakeTime < 0) awakeTime += 24 * 60; // 日をまたぐ場合
      
      // 睡眠時間を計算（次の起床まで）
      let napLength = 0;
      if (i + 2 < sortedLogs.length && sortedLogs[i + 2].type === 'wake') {
        const nextWake = sortedLogs[i + 2];
        const [nextWakeHour, nextWakeMin] = nextWake.time.split(':').map(Number);
        napLength = (nextWakeHour * 60 + nextWakeMin) - (napHour * 60 + napMin);
        if (napLength < 0) napLength += 24 * 60;
      } else {
        // 次の起床がない場合は推定
        napLength = getNapLengthByMonths(null, new Date());
      }

      patterns.push({
        wakeHour: wakeHour,
        awakeTime: awakeTime,
        napLength: napLength,
        date: dateKey
      });
    }
  }

  return patterns;
}

// 予測精度の評価と統計情報を表示する関数
function showPredictionStats() {
  const allDates = Object.keys(allLogs).sort();
  let statsHtml = '';
  
  if (allDates.length < 3) {
    statsHtml = `
      <div style="background:white; padding:15px; border-radius:6px; margin-top:10px;">
        <h3>予測精度統計</h3>
        <div style="color:#666; text-align:center; padding:20px;">
          統計分析には最低3日分のデータが必要です<br>
          <small>現在の記録: ${allDates.length}日分</small>
        </div>
      </div>
    `;
  } else {
    const stats = calculatePredictionStats();
    statsHtml = `
      <div style="background:white; padding:15px; border-radius:6px; margin-top:10px;">
        <h3>予測精度統計</h3>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">
          <div>
            <b>データ期間</b><br>
            ${stats.startDate} 〜 ${stats.endDate}<br>
            <small>（${stats.totalDays}日間）</small>
          </div>
          <div>
            <b>記録総数</b><br>
            ${stats.totalLogs}件<br>
            <small>（1日平均 ${Math.round(stats.avgLogsPerDay)}件）</small>
          </div>
          <div>
            <b>平均覚醒時間</b><br>
            ${Math.round(stats.avgAwakeTime)}分<br>
            <small>（標準偏差: ±${Math.round(stats.stdAwakeTime)}分）</small>
          </div>
          <div>
            <b>平均睡眠時間</b><br>
            ${Math.round(stats.avgNapLength)}分<br>
            <small>（標準偏差: ±${Math.round(stats.stdNapLength)}分）</small>
          </div>
        </div>
        <div style="margin-top:15px; padding:10px; background:#f0f0f0; border-radius:4px;">
          <b>睡眠パターンの傾向</b><br>
          ${stats.patternTrend}
        </div>
      </div>
    `;
  }

  // 既存の統計表示があれば更新、なければ追加
  const existingStats = document.getElementById('predictionStats');
  if (existingStats) {
    existingStats.innerHTML = statsHtml;
  } else {
    const container = document.createElement('div');
    container.id = 'predictionStats';
    container.innerHTML = statsHtml;
    document.getElementById('timelineChart').after(container);
  }
}

// 予測統計を計算する関数
function calculatePredictionStats() {
  const allDates = Object.keys(allLogs).sort();
  const startDate = allDates[0];
  const endDate = allDates[allDates.length - 1];
  const totalDays = allDates.length;
  
  let totalLogs = 0;
  let totalAwakeTime = 0;
  let totalNapLength = 0;
  let awakeTimes = [];
  let napLengths = [];
  let validPatterns = 0;

  for (const dateKey of allDates) {
    const dayLogs = allLogs[dateKey] || [];
    totalLogs += dayLogs.length;
    
    const patterns = analyzeDayPattern(dayLogs, dateKey);
    for (const pattern of patterns) {
      awakeTimes.push(pattern.awakeTime);
      napLengths.push(pattern.napLength);
      totalAwakeTime += pattern.awakeTime;
      totalNapLength += pattern.napLength;
      validPatterns++;
    }
  }

  const avgAwakeTime = validPatterns > 0 ? totalAwakeTime / validPatterns : 0;
  const avgNapLength = validPatterns > 0 ? totalNapLength / validPatterns : 0;
  
  const stdAwakeTime = calculateStandardDeviation(awakeTimes, avgAwakeTime);
  const stdNapLength = calculateStandardDeviation(napLengths, avgNapLength);

  // 睡眠パターンの傾向を分析
  const patternTrend = analyzePatternTrend(awakeTimes, napLengths);

  return {
    startDate,
    endDate,
    totalDays,
    totalLogs,
    avgLogsPerDay: totalLogs / totalDays,
    avgAwakeTime,
    avgNapLength,
    stdAwakeTime,
    stdNapLength,
    patternTrend
  };
}

// 標準偏差を計算する関数
function calculateStandardDeviation(values, mean) {
  if (values.length < 2) return 0;
  const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
  const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  return Math.sqrt(avgSquaredDiff);
}

// 睡眠パターンの傾向を分析する関数
function analyzePatternTrend(awakeTimes, napLengths) {
  if (awakeTimes.length < 3) return 'データ不足のため傾向を分析できません';

  // 時系列での変化を分析
  const recentAwake = awakeTimes.slice(-Math.floor(awakeTimes.length / 3));
  const earlyAwake = awakeTimes.slice(0, Math.floor(awakeTimes.length / 3));
  
  const recentAvg = recentAwake.reduce((sum, val) => sum + val, 0) / recentAwake.length;
  const earlyAvg = earlyAwake.reduce((sum, val) => sum + val, 0) / earlyAwake.length;
  
  let trend = '';
  if (recentAvg > earlyAvg + 30) {
    trend = '覚醒時間が徐々に長くなっています';
  } else if (recentAvg < earlyAvg - 30) {
    trend = '覚醒時間が徐々に短くなっています';
  } else {
    trend = '覚醒時間は安定しています';
  }

  // 睡眠時間の一貫性
  const napStd = calculateStandardDeviation(napLengths, napLengths.reduce((sum, val) => sum + val, 0) / napLengths.length);
  if (napStd < 30) {
    trend += '、睡眠時間は一貫しています';
  } else if (napStd > 60) {
    trend += '、睡眠時間にばらつきがあります';
  } else {
    trend += '、睡眠時間はややばらつきがあります';
  }

  return trend;
}

// 睡眠データをエクスポートする関数
function exportSleepData() {
  const allDates = Object.keys(allLogs).sort();
  if (allDates.length === 0) {
    alert('エクスポートするデータがありません');
    return;
  }

  let csvContent = '日付,時刻,タイプ\n';
  
  for (const dateKey of allDates) {
    const dayLogs = allLogs[dateKey] || [];
    for (const log of dayLogs) {
      const date = dateKey.replace(/\//g, '-');
      const type = log.type === 'wake' ? '起床' : '睡眠';
      csvContent += `${date},${log.time},${type}\n`;
    }
  }

  // CSVファイルをダウンロード
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', `baby_sleep_data_${new Date().toISOString().split('T')[0]}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // ステータス更新
  const status = document.getElementById('analysisStatus');
  if (status) {
    status.textContent = `エクスポート完了（${allDates.length}日分）`;
    setTimeout(() => { status.textContent = ''; }, 3000);
  }
}



// 既存データからdetailsフィールドを削除（詳細記録機能削除のため）
function cleanupDetailsField() {
  let hasChanges = false;
  for (const dateKey in allLogs) {
    const dayLogs = allLogs[dateKey] || [];
    for (const log of dayLogs) {
      if (log.details !== undefined) {
        delete log.details;
        hasChanges = true;
      }
    }
  }
  if (hasChanges) {
    saveAllLogs();
  }
}

// 初期化
// 表示日初期値を今日に設定し、日付入力にも反映
cleanupDetailsField();
setCurrentDateKey(currentDateKey);
const viewDateEl = document.getElementById('viewDate');
if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);

// 予測精度統計を自動表示
showPredictionStats();

// 時刻入力の初期値を現在時刻に設定
const timeInputEl = document.getElementById('timeInput');
if (timeInputEl) {
  timeInputEl.value = nowTimeString();
}

// 生年月日の初期化
const birthInputEl = document.getElementById('birthInput');
if (birthInputEl) {
  const saved = localStorage.getItem(BIRTH_KEY);
  if (saved) {
    birthInputEl.value = saved;
    const bd = loadBirth();
    if (bd) {
      document.getElementById('birthStatus').textContent = `保存済み（月齢: ${calculateMonthsAge(bd)}ヶ月）`;
    }
  }
  birthInputEl.addEventListener('change', () => {
    // 入力変更で即保存
    saveBirth(false);
  });
}

// 表示日の date 入力変更で切替
const viewDateEl2 = document.getElementById('viewDate');
if (viewDateEl2) {
  viewDateEl2.addEventListener('change', (e) => {
    const v = e.target.value; // YYYY-MM-DD
    if (!v) return;
    const key = v.replace(/-/g, '/');
    setCurrentDateKey(key);
  });
}

// 範囲は固定（1週間）
</script>

<script>
// PWA Service Worker登録
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js');
}
</script>

</body>
</html>
