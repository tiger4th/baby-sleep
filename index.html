<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ベビースリープ予測</title>
<link rel="manifest" href="./manifest.json">
<style>
body { font-family: sans-serif; padding: 10px; background: #f5f5f5; }
h1 { font-size: 1.4em; }
button { margin: 5px; padding: 10px; font-size: 1em; }
#log, #prediction { margin-top: 10px; background: white; padding: 10px; border-radius: 6px; }
canvas { background: white; margin-top: 15px; border-radius: 6px; }
</style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js?v=20250810-1"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.umd.min.js?v=20250810-1"></script>
</head>
<body>

<h1>ベビースリープ予測</h1>
<div>
  <button onclick="addLog('wake')">起きた</button>
  <button onclick="addLog('nap')">寝た</button>
</div>
  
  <div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
    <b>時間指定で追加／編集</b><br>
    <select id="typeSelect">
      <option value="wake">起きた</option>
      <option value="nap">寝た</option>
    </select>
    <input id="timeInput" type="time" step="60">
    <button id="addBtn" onclick="handleAddOrUpdate()">この時間で追加</button>
    <button id="cancelEditBtn" onclick="cancelEdit()" style="display:none;">キャンセル</button>
    <span id="editStatus" style="margin-left:8px;color:#666;"></span>
  </div>

  <div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
    <b>生年月日</b><br>
    <input id="birthInput" type="date">
    <button onclick="saveBirth()">保存</button>
    <span id="birthStatus" style="margin-left:8px;color:#666;"></span>
  </div>

  <div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
    <b>表示日</b><br>
    <input id="viewDate" type="date">
    <button onclick="goToday()">今日</button>
    <button onclick="shiftDay(-1)">前日</button>
    <button onclick="shiftDay(1)">翌日</button>
    <span id="viewDateStatus" style="margin-left:8px;color:#666;"></span>
  </div>

<div id="log"></div>
<div id="prediction"></div>
<canvas id="timelineChart" height="150"></canvas>

<div style="margin-top:10px; background:white; padding:10px; border-radius:6px;">
  <b>ぴよログからインポート</b><br>
  <input id="piyoFile" type="file" accept=".txt">
  <button onclick="handleImportPiyolog()">インポート</button>
  <span id="importStatus" style="margin-left:8px;color:#666;"></span>
  <div style="color:#888; font-size:0.9em; margin-top:6px;">
    ファイルに含まれる全ての日の「起きる／寝る」を取り込みます（同日の既存記録は上書き）。
  </div>
</div>

<script>
// データ構造を日付ごとの辞書に移行（互換: 旧配列→今日の日付に移行）
let allLogsRaw = null;
try {
  allLogsRaw = JSON.parse(localStorage.getItem('babyLogs') || 'null');
} catch (_) {
  allLogsRaw = null;
}

function __computeTodayKey() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}/${m}/${day}`;
}

let allLogs = {};
if (Array.isArray(allLogsRaw)) {
  // 旧形式（配列）→ 今日の日付に移し替え
  const todayKey = __computeTodayKey();
  allLogs[todayKey] = allLogsRaw.filter(l => l && (l.type === 'wake' || l.type === 'nap'));
} else if (allLogsRaw && typeof allLogsRaw === 'object') {
  allLogs = allLogsRaw;
  // 各日ごとに型フィルタを適用
  for (const k of Object.keys(allLogs)) {
    const arr = Array.isArray(allLogs[k]) ? allLogs[k] : [];
    allLogs[k] = arr.filter(l => l && (l.type === 'wake' || l.type === 'nap'));
  }
} else {
  const todayKey = __computeTodayKey();
  allLogs[todayKey] = [];
}
localStorage.setItem('babyLogs', JSON.stringify(allLogs));

let currentDateKey = __computeTodayKey();
let logs = allLogs[currentDateKey] || [];
let timelineChart = null;
let editingIndex = null;
const BIRTH_KEY = "babyBirthDate"; // YYYY-MM-DD で保存

function nowTimeString() {
  const now = new Date();
  const hh = String(now.getHours()).padStart(2, '0');
  const mm = String(now.getMinutes()).padStart(2, '0');
  return `${hh}:${mm}`;
}

function getSortKey(timeStr) {
  const [h, m] = timeStr.split(":").map(Number);
  // 07:00を日境界にし、<07:00 は翌日扱い
  const minutes = h * 60 + m;
  return minutes < 7 * 60 ? minutes + 24 * 60 : minutes;
}

function sortLogs() {
  logs.sort((a, b) => getSortKey(a.time) - getSortKey(b.time));
}

function saveAllLogs() {
  localStorage.setItem('babyLogs', JSON.stringify(allLogs));
}

function setCurrentDateKey(newKey) {
  currentDateKey = newKey;
  if (!allLogs[currentDateKey]) allLogs[currentDateKey] = [];
  // 型フィルタ
  allLogs[currentDateKey] = allLogs[currentDateKey].filter(l => l && (l.type === 'wake' || l.type === 'nap'));
  logs = allLogs[currentDateKey];
  sortLogs();
  saveAllLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  updateViewDateStatus();
}

function keyFromInputValue(value) { // YYYY-MM-DD -> YYYY/MM/DD
  if (!value) return null;
  const [y, m, d] = value.split('-');
  return `${y}/${m}/${d}`;
}

function inputValueFromKey(key) { // YYYY/MM/DD -> YYYY-MM-DD
  if (!key) return '';
  const [y, m, d] = key.split('/');
  return `${y}-${m}-${d}`;
}

function goToday() {
  setCurrentDateKey(__computeTodayKey());
  const viewDateEl = document.getElementById('viewDate');
  if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);
}

function shiftDay(delta) {
  const [y, m, d] = currentDateKey.split('/').map(Number);
  const dt = new Date(y, m - 1, d);
  dt.setDate(dt.getDate() + delta);
  const key = `${dt.getFullYear()}/${String(dt.getMonth() + 1).padStart(2, '0')}/${String(dt.getDate()).padStart(2, '0')}`;
  setCurrentDateKey(key);
  const viewDateEl = document.getElementById('viewDate');
  if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);
}

function updateViewDateStatus() {
  const status = document.getElementById('viewDateStatus');
  if (!status) return;
  status.textContent = `表示中: ${currentDateKey}（${logs.length}件）`;
}

function addLog(type) {
  const time = nowTimeString();
  addLogAt(type, time);
}

function addLogAt(type, time) {
  if (!time || !/^\d{2}:\d{2}$/.test(time)) {
    alert('時刻は HH:MM 形式で指定してください');
    return;
  }
  if (!(type === 'wake' || type === 'nap')) {
    alert('追加できるのは「起きた」「寝た」のみです');
    return;
  }
  logs.push({ type, time });
  sortLogs();
  allLogs[currentDateKey] = logs;
  saveAllLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
}

function startEditLog(index) {
  const target = logs[index];
  if (!target) return;
  editingIndex = index;
  document.getElementById('typeSelect').value = target.type;
  document.getElementById('timeInput').value = target.time;
  const addBtn = document.getElementById('addBtn');
  addBtn.textContent = '更新';
  document.getElementById('cancelEditBtn').style.display = '';
  document.getElementById('editStatus').textContent = `編集中: ${target.time} - ${translateType(target.type)}`;
}

function handleAddOrUpdate() {
  const type = document.getElementById('typeSelect').value;
  const time = document.getElementById('timeInput').value;
  if (!time || !/^\d{2}:\d{2}$/.test(time)) {
    alert('時刻は HH:MM 形式で指定してください');
    return;
  }
  if (editingIndex === null) {
    addLogAt(type, time);
  } else {
    logs[editingIndex] = { type, time };
    sortLogs();
    allLogs[currentDateKey] = logs;
    saveAllLogs();
    renderLogs();
    updateTimelineChart();
    updatePrediction();
    cancelEdit();
  }
}

function cancelEdit() {
  editingIndex = null;
  const addBtn = document.getElementById('addBtn');
  addBtn.textContent = 'この時間で追加';
  document.getElementById('cancelEditBtn').style.display = 'none';
  document.getElementById('editStatus').textContent = '';
  const timeInputEl = document.getElementById('timeInput');
  if (timeInputEl) timeInputEl.value = nowTimeString();
}

function deleteLog(index) {
  const target = logs[index];
  if (!target) return;
  const ok = confirm(`削除しますか？\n${target.time} - ${translateType(target.type)}`);
  if (!ok) return;
  logs.splice(index, 1);
  allLogs[currentDateKey] = logs;
  saveAllLogs();
  sortLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  cancelEdit();
}

function renderLogs() {
  const container = document.getElementById("log");
  const total = logs.length;
  const recentCount = 3;
  const header = "<b>記録</b><br>";

  if (total <= recentCount) {
    const allHtml = logs.map((l, i) => `${l.time} - ${translateType(l.type)} ` +
      `<button onclick="startEditLog(${i})">編集</button> ` +
      `<button onclick="deleteLog(${i})">削除</button>`).join("<br>");
    container.innerHTML = header + allHtml;
    return;
  }

  const olderCount = total - recentCount;
  const recentBaseIndex = total - recentCount;

  const olderHtml = logs.slice(0, olderCount).map((l, i) => {
    const idx = i; // 先頭からのインデックスはそのまま
    return `${l.time} - ${translateType(l.type)} ` +
      `<button onclick="startEditLog(${idx})">編集</button> ` +
      `<button onclick="deleteLog(${idx})">削除</button>`;
  }).join("<br>");

  const recentHtml = logs.slice(recentBaseIndex).map((l, i) => {
    const idx = recentBaseIndex + i; // 元配列でのインデックス
    return `${l.time} - ${translateType(l.type)} ` +
      `<button onclick="startEditLog(${idx})">編集</button> ` +
      `<button onclick="deleteLog(${idx})">削除</button>`;
  }).join("<br>");

  const detailsHtml =
    `<details>` +
      `<summary>過去の記録を表示（${olderCount}件）</summary>` +
      `${olderHtml ? `<div style="margin-top:8px;">${olderHtml}</div>` : ""}` +
    `</details>`;

  // 昇順の表示順を維持するため、先に折りたたみ、その後に直近3件を表示
  container.innerHTML = header + detailsHtml + "<br>" + recentHtml;
}

function translateType(type) {
  return type === "wake" ? "起きた" :
         type === "nap" ? "寝た" : type;
}

// 生年月日の保存・読込と月齢ベースの推定
function saveBirth(showSavedMessage = true) {
  const input = document.getElementById('birthInput');
  const status = document.getElementById('birthStatus');
  if (!input || !status) return;
  const value = input.value; // YYYY-MM-DD or ''
  if (!value) {
    localStorage.removeItem(BIRTH_KEY);
    status.textContent = '未設定';
    updatePrediction();
    return;
  }
  // 簡易バリデーション
  if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) {
    status.textContent = '日付形式が不正です (YYYY-MM-DD)';
    return;
  }
  localStorage.setItem(BIRTH_KEY, value);
  const birth = loadBirth();
  const months = birth ? calculateMonthsAge(birth) : null;
  status.textContent = months !== null ? `保存しました（月齢: ${months}ヶ月）` : '保存しました';
  if (!showSavedMessage) {
    // 即時保存時は控えめな表示
    status.textContent = months !== null ? `保存済み（月齢: ${months}ヶ月）` : '保存済み';
  }
  updatePrediction();
}

function loadBirth() {
  const stored = localStorage.getItem(BIRTH_KEY);
  if (!stored) return null;
  // Local 00:00 に設定
  const [y, m, d] = stored.split('-').map(Number);
  const dt = new Date();
  dt.setHours(0, 0, 0, 0);
  dt.setFullYear(y, m - 1, d);
  return isNaN(dt.getTime()) ? null : dt;
}

function calculateMonthsAge(birthDate, refDate = new Date()) {
  if (!birthDate) return null;
  const y1 = birthDate.getFullYear();
  const m1 = birthDate.getMonth();
  const d1 = birthDate.getDate();
  const y2 = refDate.getFullYear();
  const m2 = refDate.getMonth();
  const d2 = refDate.getDate();
  let months = (y2 - y1) * 12 + (m2 - m1);
  if (d2 < d1) months -= 1; // 当月の誕生日未到達なら-1
  return Math.max(0, months);
}

function getAwakeWindowByMonths(monthsAge) {
  // 参考レンジ（分）: 文献や一般的な目安に基づく緩めの範囲
  if (monthsAge === null) return [120, 150];
  if (monthsAge <= 2) return [45, 90];
  if (monthsAge <= 4) return [75, 120];
  if (monthsAge <= 6) return [90, 150];
  if (monthsAge <= 8) return [120, 180];
  if (monthsAge <= 10) return [150, 210];
  if (monthsAge <= 12) return [180, 240];
  return [210, 300];
}

function getNapLengthByMonths(monthsAge, nextNapStart) {
  const hour = nextNapStart.getHours();
  // 基本レンジ（分）
  let minMax;
  if (monthsAge === null) {
    minMax = [60, 90];
  } else if (monthsAge <= 2) {
    minMax = [60, 120];
  } else if (monthsAge <= 4) {
    minMax = [60, 120];
  } else if (monthsAge <= 6) {
    minMax = [60, 90];
  } else if (monthsAge <= 8) {
    minMax = [45, 90];
  } else if (monthsAge <= 12) {
    minMax = [45, 90];
  } else {
    minMax = [45, 60];
  }
  let nap = randomIntInclusive(minMax[0], minMax[1]);
  // 15時以降は短めに制限
  if (hour >= 15) {
    nap = Math.min(nap, 45);
  }
  return nap;
}

function randomIntInclusive(min, max) {
  const mn = Math.ceil(min);
  const mx = Math.floor(max);
  return Math.floor(Math.random() * (mx - mn + 1)) + mn;
}

function updatePrediction() {
  if (logs.length === 0) {
    document.getElementById("prediction").innerHTML = "この日の起床ログ後に予測が表示されます。";
    return;
  }
  // 直近の「状態」ログ（wake/nap）のみを見る。
  const lastStateIndex = [...logs].map((l, i) => ({...l, i}))
    .filter(l => l.type === 'wake' || l.type === 'nap')
    .map(l => l.i)
    .pop();
  if (lastStateIndex === undefined) {
    document.getElementById("prediction").innerHTML = "この日の起床ログ後に予測が表示されます。";
    return;
  }
  const lastState = logs[lastStateIndex];
  if (lastState.type !== 'wake') {
    document.getElementById("prediction").innerHTML = "この日の起床ログ後に予測が表示されます。";
    return;
  }

  const [h, m] = lastState.time.split(":").map(Number);
  const wakeTime = new Date();
  wakeTime.setHours(h, m);

  const birthDate = loadBirth();
  const monthsAge = birthDate ? calculateMonthsAge(birthDate, new Date()) : null;

  const [awakeMin, awakeMax] = getAwakeWindowByMonths(monthsAge);
  const awakeMinutes = randomIntInclusive(awakeMin, awakeMax);
  const nextNapStart = new Date(wakeTime.getTime() + awakeMinutes * 60000);

  const napLengthMinutes = getNapLengthByMonths(monthsAge, nextNapStart);
  const wakeUpTime = new Date(nextNapStart.getTime() + napLengthMinutes * 60000);

  const monthsInfo = monthsAge !== null ? `（月齢: ${monthsAge}ヶ月）` : "";

  document.getElementById("prediction").innerHTML =
    `<b>次の寝かしつけ目安</b>${monthsInfo}<br>
     ${formatTime(nextNapStart)}ごろベッドに<br>
     <b>入眠予測</b> ${formatTime(new Date(nextNapStart.getTime() + 5*60000))}<br>
     <b>起床予測</b> ${formatTime(wakeUpTime)}`;
}

function formatTime(date) {
  return date.toTimeString().slice(0,5);
}

function updateTimelineChart() {
  const isDateAdapterReady = () => {
    const a = Chart && Chart._adapters && Chart._adapters._date;
    return !!(a && a.format && a.parse && a.add && a.diff && a.startOf && a.endOf && a.formats);
  };
  const events = [];
  // 表示日の 07:00 を軸にする
  const [y, m, d] = currentDateKey.split('/').map(Number);
  const dayStart = new Date(y, m - 1, d, 7, 0, 0, 0);
  const dayStartMs = dayStart.getTime();
  let axisMaxMs = dayStartMs + 24 * 3600000;

  // 「状態」ログ（wake/nap）のみで区間を作成。ミルク等は無視。
  const stateLogs = logs.filter(l => l.type === 'wake' || l.type === 'nap');
  for (let i = 0; i < stateLogs.length - 1; i++) {
    const current = stateLogs[i];
    const next = stateLogs[i + 1];

    const [sh, sm] = current.time.split(":").map(Number);
    const [eh, em] = next.time.split(":").map(Number);

    let startDate = new Date(dayStart);
    let endDate = new Date(dayStart);

    if (sh < 7) startDate.setDate(startDate.getDate() + 1);
    startDate.setHours(sh, sm);

    if (eh < 7) endDate.setDate(endDate.getDate() + 1);
    endDate.setHours(eh, em);

    const label = current.type === "nap" ? "睡眠" : "起きてる";
    const color = current.type === "nap" ? "#4CAF50" : "#FF9800";

    const ev = {
      label,
      start: startDate,
      end: endDate,
      color
    };
    events.push(ev);
    const endMs = endDate.getTime();
    if (endMs > axisMaxMs) axisMaxMs = endMs;
  }

  // 先頭の持ち越し睡眠（前日が「寝た」で終わっている場合、7:00〜当日最初の起床まで睡眠帯を追加）
  if (stateLogs.length > 0) {
    const dtPrev = new Date(y, m - 1, d);
    dtPrev.setDate(dtPrev.getDate() - 1);
    const prevKey = `${dtPrev.getFullYear()}/${String(dtPrev.getMonth() + 1).padStart(2,'0')}/${String(dtPrev.getDate()).padStart(2,'0')}`;
    const prevStateLogs = (allLogs[prevKey] || []).filter(l => l.type === 'wake' || l.type === 'nap').sort((a,b)=>getSortKey(a.time)-getSortKey(b.time));
    if (prevStateLogs.length > 0 && prevStateLogs[prevStateLogs.length - 1].type === 'nap') {
      // 当日の最初の wake を探す（7:00以降の起床）
      const firstWake = stateLogs.find(l => l.type === 'wake' && parseInt(l.time.split(':')[0],10) >= 7);
      if (firstWake) {
        const [eh, em] = firstWake.time.split(':').map(Number);
        const startDate = new Date(dayStart);
        const endDate = new Date(dayStart);
        endDate.setHours(eh, em);
        const ev = { label: '睡眠', start: startDate, end: endDate, color: '#4CAF50' };
        events.push(ev);
        const endMs = endDate.getTime();
        if (endMs > axisMaxMs) axisMaxMs = endMs;
      }
    }
  }

  // 追加: 最後が「寝た」で終わっている場合、翌日の最初の「起きた」までを睡眠として表示
  if (stateLogs.length > 0 && stateLogs[stateLogs.length - 1].type === 'nap') {
    const lastNap = stateLogs[stateLogs.length - 1];
    // 翌日キー
    const dt = new Date(y, m - 1, d);
    dt.setDate(dt.getDate() + 1);
    const nextKey = `${dt.getFullYear()}/${String(dt.getMonth() + 1).padStart(2,'0')}/${String(dt.getDate()).padStart(2,'0')}`;
    const nextStateLogs = (allLogs[nextKey] || []).filter(l => l.type === 'wake' || l.type === 'nap');
    nextStateLogs.sort((a, b) => getSortKey(a.time) - getSortKey(b.time));
    const firstWake = nextStateLogs.find(l => l.type === 'wake');
    if (firstWake) {
      const [sh, sm] = lastNap.time.split(':').map(Number);
      const [eh, em] = firstWake.time.split(':').map(Number);
      let startDate = new Date(dayStart);
      if (sh < 7) startDate.setDate(startDate.getDate() + 1);
      startDate.setHours(sh, sm);
      let endDate = new Date(dayStartMs + 24 * 3600000); // 翌日基準
      endDate.setHours(eh, em);
      const ev = { label: '睡眠', start: startDate, end: endDate, color: '#4CAF50' };
      events.push(ev);
      const endMs = endDate.getTime();
      if (endMs > axisMaxMs) axisMaxMs = endMs;
    }
  }

  const ctx = document.getElementById('timelineChart').getContext('2d');
  if (timelineChart) timelineChart.destroy();

  const awakeData = events
    .filter(ev => ev.label === '起きてる')
    .map(ev => ({ x: [ev.start.getTime(), ev.end.getTime()], y: 'スケジュール' }));
  const sleepData = events
    .filter(ev => ev.label === '睡眠')
    .map(ev => ({ x: [ev.start.getTime(), ev.end.getTime()], y: 'スケジュール' }));

  const baseConfig = {
    type: 'bar',
    data: {
      labels: ["スケジュール"],
      datasets: [
        {
          label: '起床中',
          data: awakeData,
          backgroundColor: '#FF9800',
          borderSkipped: false,
          barPercentage: 0.9,
          categoryPercentage: 1.0,
          grouped: false
        },
        {
          label: '睡眠中',
          data: sleepData,
          backgroundColor: '#4CAF50',
          borderSkipped: false,
          barPercentage: 0.9,
          categoryPercentage: 1.0,
          grouped: false
        }
      ]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      plugins: { legend: { display: true } },
      scales: { x: {} }
    }
  };

  const timeseriesX = {
    type: 'timeseries',
    time: { unit: 'hour', displayFormats: { hour: 'HH:mm' } },
    min: dayStart,
    max: new Date(axisMaxMs)
  };
  const linearX = {
    type: 'linear',
    min: dayStartMs,
    max: axisMaxMs,
    ticks: { callback: (value) => formatTime(new Date(value)) }
  };

  try {
    baseConfig.options.scales.x = isDateAdapterReady() ? timeseriesX : linearX;
    timelineChart = new Chart(ctx, baseConfig);
  } catch (err) {
    console.warn('Chart init failed, fallback to linear scale:', err);
    baseConfig.options.scales.x = linearX;
    timelineChart = new Chart(ctx, baseConfig);
  }
}

// ぴよログ取り込み
function handleImportPiyolog() {
  const input = document.getElementById('piyoFile');
  const status = document.getElementById('importStatus');
  if (!input || !input.files || input.files.length === 0) {
    status.textContent = 'ファイルを選択してください';
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const text = String(reader.result || '');
      const parsed = parsePiyologTextMulti(text);
      const keys = Object.keys(parsed);
      if (keys.length === 0) {
        status.textContent = '取り込める記録が見つかりませんでした';
        return;
      }
      // 各日を上書き保存
      for (const k of keys) {
        const items = parsed[k].filter(l => l && (l.type === 'wake' || l.type === 'nap'));
        allLogs[k] = items;
      }
      saveAllLogs();
      // 最終日のキーに移動
      const latestKey = keys.sort((a, b) => parseDateKey(a) - parseDateKey(b))[keys.length - 1];
      setCurrentDateKey(latestKey);
      status.textContent = `インポート完了（${keys.length}日 / 最終日: ${latestKey}）`;
    } catch (e) {
      console.error(e);
      status.textContent = 'インポート中にエラーが発生しました';
    }
  };
  reader.onerror = () => {
    status.textContent = 'ファイルの読み込みに失敗しました';
  };
  reader.readAsText(file, 'utf-8');
}

function parsePiyologText(text) {
  const lines = text.split(/\r?\n/);
  const dateHeaderRegex = /^\s*(\d{4})\/(\d{1,2})\/(\d{1,2})\s*\(/;
  const timeLineRegex = /^\s*(\d{2}):(\d{2})\s+(.+)/;

  /** @type {Record<string, Array<{time: string, type: 'wake'|'nap'}>>} */
  const dateToItems = {};
  let currentDateKey = null;

  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const dh = dateHeaderRegex.exec(line);
    if (dh) {
      const y = dh[1].padStart(4, '0');
      const m = dh[2].padStart(2, '0');
      const d = dh[3].padStart(2, '0');
      currentDateKey = `${y}/${m}/${d}`;
      if (!dateToItems[currentDateKey]) dateToItems[currentDateKey] = [];
      continue;
    }
    if (!currentDateKey) continue;
    const tl = timeLineRegex.exec(line);
    if (!tl) continue;
    const hh = tl[1];
    const mm = tl[2];
    const body = tl[3];
    const time = `${hh}:${mm}`;
    let type = null;
    if (body.startsWith('起きる')) type = 'wake';
    else if (body.startsWith('寝る')) type = 'nap';
    if (type) {
      dateToItems[currentDateKey].push({ time, type });
    }
  }

  const keys = Object.keys(dateToItems);
  if (keys.length === 0) return { dateKey: null, items: [] };
  const latestKey = keys.sort((a, b) => parseDateKey(a) - parseDateKey(b))[keys.length - 1];
  return { dateKey: latestKey, items: dateToItems[latestKey] };
}

function parseDateKey(key) {
  // key: YYYY/MM/DD
  const [y, m, d] = key.split('/').map(Number);
  const dt = new Date();
  dt.setHours(0, 0, 0, 0);
  dt.setFullYear(y, m - 1, d);
  return dt.getTime();
}

// 複数日を返す版
function parsePiyologTextMulti(text) {
  const lines = text.split(/\r?\n/);
  const dateHeaderRegex = /^\s*(\d{4})\/(\d{1,2})\/(\d{1,2})\s*\(/;
  const timeLineRegex = /^\s*(\d{2}):(\d{2})\s+(.+)/;
  /** @type {Record<string, Array<{time: string, type: 'wake'|'nap'}>>} */
  const dateToItems = {};
  let currentDateKey = null;
  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const dh = dateHeaderRegex.exec(line);
    if (dh) {
      const y = dh[1].padStart(4, '0');
      const m = dh[2].padStart(2, '0');
      const d = dh[3].padStart(2, '0');
      currentDateKey = `${y}/${m}/${d}`;
      if (!dateToItems[currentDateKey]) dateToItems[currentDateKey] = [];
      continue;
    }
    if (!currentDateKey) continue;
    const tl = timeLineRegex.exec(line);
    if (!tl) continue;
    const hh = tl[1];
    const mm = tl[2];
    const body = tl[3];
    const time = `${hh}:${mm}`;
    let type = null;
    if (body.startsWith('起きる')) type = 'wake';
    else if (body.startsWith('寝る')) type = 'nap';
    if (type) {
      dateToItems[currentDateKey].push({ time, type });
    }
  }
  return dateToItems;
}

// 初期化
// 表示日初期値を今日に設定し、日付入力にも反映
setCurrentDateKey(currentDateKey);
const viewDateEl = document.getElementById('viewDate');
if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);

// 時刻入力の初期値を現在時刻に設定
const timeInputEl = document.getElementById('timeInput');
if (timeInputEl) {
  timeInputEl.value = nowTimeString();
}

// 生年月日の初期化
const birthInputEl = document.getElementById('birthInput');
if (birthInputEl) {
  const saved = localStorage.getItem(BIRTH_KEY);
  if (saved) {
    birthInputEl.value = saved;
    const bd = loadBirth();
    if (bd) {
      document.getElementById('birthStatus').textContent = `保存済み（月齢: ${calculateMonthsAge(bd)}ヶ月）`;
    }
  }
  birthInputEl.addEventListener('change', () => {
    // 入力変更で即保存
    saveBirth(false);
  });
}

// 表示日の date 入力変更で切替
const viewDateEl2 = document.getElementById('viewDate');
if (viewDateEl2) {
  viewDateEl2.addEventListener('change', (e) => {
    const v = e.target.value; // YYYY-MM-DD
    if (!v) return;
    const key = v.replace(/-/g, '/');
    setCurrentDateKey(key);
  });
}
</script>

<script>
// PWA Service Worker登録
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js');
}
</script>

</body>
</html>
