<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ベビースリープ予測</title>
<link rel="manifest" href="./manifest.json">
<style>
/* モダンなカラーパレット */
:root {
  --primary-color: #6366f1;
  --primary-hover: #4f46e5;
  --secondary-color: #10b981;
  --secondary-hover: #059669;
  --accent-color: #f59e0b;
  --accent-hover: #d97706;
  --danger-color: #ef4444;
  --danger-hover: #dc2626;
  --background-color: #f8fafc;
  --card-background: #ffffff;
  --text-primary: #1e293b;
  --text-secondary: #64748b;
  --text-muted: #94a3b8;
  --border-color: #e2e8f0;
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  
  /* 予測・チャート用の改善された色 */
  --prediction-bg: #f0f9ff;
  --prediction-border: #0ea5e9;
  --prediction-text: #0c4a6e;
  --prediction-text-secondary: #0369a1;
  --chart-awake: #ef4444;
  --chart-sleep: #3b82f6;
  --chart-bg: #ffffff;
  --chart-border: #e2e8f0;
}

/* ベーススタイル */
* {
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
  margin: 0;
  padding: 0;
  background: var(--background-color);
  color: var(--text-primary);
  line-height: 1.6;
  font-size: 16px;
}

/* ヘッダー */
.app-header {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 50%, var(--accent-color) 100%);
  color: white;
  padding: 2rem 1rem;
  text-align: center;
  margin-bottom: 2rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
}

.app-header::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
  animation: shimmer 3s ease-in-out infinite;
}

@keyframes shimmer {
  0%, 100% { transform: translateX(-100%); }
  50% { transform: translateX(100%); }
}

.app-header h1 {
  margin: 0;
  font-size: 2rem;
  font-weight: 700;
  text-shadow: 0 2px 4px rgba(0,0,0,0.1);
  position: relative;
  z-index: 1;
}

.app-header .subtitle {
  margin-top: 0.5rem;
  opacity: 0.9;
  font-size: 1.1rem;
  position: relative;
  z-index: 1;
}

/* メインコンテナ */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}

/* カードベースのレイアウト */
.card {
  background: var(--card-background);
  border-radius: var(--radius-lg);
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  box-shadow: var(--shadow-md);
  border: 1px solid var(--border-color);
  transition: all 0.2s ease;
}

.card:hover {
  box-shadow: var(--shadow-lg);
  transform: translateY(-3px);
  border-color: var(--primary-color);
}

.card-header {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 0.75rem;
  border-bottom: 2px solid var(--border-color);
}

.card-header h3 {
  margin: 0;
  color: var(--text-primary);
  font-size: 1.25rem;
  font-weight: 600;
}

.card-header .icon {
  margin-right: 0.75rem;
  font-size: 1.5rem;
  color: var(--primary-color);
}

/* ボタンスタイル */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  font-weight: 500;
  border: none;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all 0.2s ease;
  text-decoration: none;
  min-height: 44px;
  gap: 0.5rem;
}

.btn-primary {
  background: var(--primary-color);
  color: white;
}

.btn-primary:hover {
  background: var(--primary-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: var(--primary-hover);
}

.btn-secondary {
  background: var(--secondary-color);
  color: white;
}

.btn-secondary:hover {
  background: var(--secondary-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: var(--secondary-hover);
}

.btn-accent {
  background: var(--accent-color);
  color: white;
}

.btn-accent:hover {
  background: var(--accent-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: var(--accent-hover);
}

.btn-danger {
  background: var(--danger-color);
  color: white;
}

.btn-danger:hover {
  background: var(--danger-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: var(--danger-hover);
}

.btn-outline {
  background: transparent;
  color: var(--primary-color);
  border: 2px solid var(--primary-color);
}

.btn-outline:hover {
  background: var(--primary-color);
  color: white;
}

.btn-sm {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  min-height: 36px;
}

.form-label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: var(--text-primary);
}

.form-control {
  width: 100%;
  padding: 0.75rem;
  border: 2px solid var(--border-color);
  border-radius: var(--radius-md);
  font-size: 1rem;
  transition: border-color 0.2s ease;
  background: var(--card-background);
  color: var(--text-primary);
}

.form-control:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
  transform: translateY(-1px);
  transition: all 0.2s ease;
}

.form-control:disabled {
  background: var(--background-color);
  cursor: not-allowed;
}

/* セレクトボックス */
select.form-control {
  cursor: pointer;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
  appearance: none;
}

/* ボタングループ */
.btn-group {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
  align-items: center;
}

.btn-group .btn {
  flex: 1;
  min-width: 120px;
}

/* グリッドレイアウト */
.grid {
  display: grid;
  gap: 1.5rem;
}

.grid-cols-1 { grid-template-columns: 1fr; }
.grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
.grid-cols-3 { grid-template-columns: repeat(3, 1fr); }

/* ステータス表示 */
.status {
  display: inline-flex;
  align-items: center;
  padding: 0.25rem 0.75rem;
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  font-weight: 500;
}

.status-success {
  background: rgba(16, 185, 129, 0.1);
  color: var(--secondary-color);
}

.status-info {
  background: rgba(99, 102, 241, 0.1);
  color: var(--primary-color);
}

.status-warning {
  background: rgba(245, 158, 11, 0.1);
  color: var(--accent-color);
}

/* ログ表示 */
.log-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  margin-bottom: 0.75rem;
  background: var(--card-background);
  border-radius: var(--radius-md);
  border-left: 4px solid var(--primary-color);
  transition: all 0.2s ease;
  border: 1px solid var(--border-color);
}

.log-item:hover {
  transform: translateX(3px);
  box-shadow: var(--shadow-md);
  border-left-width: 6px;
}

.log-item.wake {
  border-left-color: var(--accent-color);
  background: linear-gradient(135deg, var(--card-background), rgba(245, 158, 11, 0.05));
}

.log-item.nap {
  border-left-color: var(--secondary-color);
  background: linear-gradient(135deg, var(--card-background), rgba(16, 185, 129, 0.05));
}

.log-time {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.1rem;
}

.log-type {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.log-actions {
  display: flex;
  gap: 0.5rem;
}

/* 予測表示 */
.prediction-card {
  background: var(--prediction-bg);
  border: 2px solid var(--prediction-border);
  color: var(--prediction-text);
  box-shadow: 0 4px 6px -1px rgba(14, 165, 233, 0.1), 0 2px 4px -2px rgba(14, 165, 233, 0.1);
  position: relative;
  overflow: hidden;
}

.prediction-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, var(--prediction-border), var(--primary-color));
}

.prediction-time {
  font-size: 2rem;
  font-weight: 900;
  color: var(--prediction-text);
  text-align: center;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
  letter-spacing: 0.1em;
  background: linear-gradient(135deg, var(--prediction-text), var(--prediction-text-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.prediction-label {
  font-size: 1rem;
  color: var(--prediction-text-secondary);
  text-align: center;
  margin-bottom: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  opacity: 0.9;
}

.prediction-item {
  text-align: center;
  padding: 1rem;
  position: relative;
  transition: all 0.3s ease;
  border-radius: var(--radius-md);
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border: 1px solid var(--prediction-border);
}

.prediction-item:hover {
  background: rgba(14, 165, 233, 0.15);
  transform: translateY(-3px);
  box-shadow: 0 8px 25px rgba(14, 165, 233, 0.2);
}

.prediction-item:not(:last-child)::after {
  content: '';
  position: absolute;
  right: 0;
  top: 20%;
  bottom: 20%;
  width: 1px;
  background: linear-gradient(to bottom, transparent, var(--prediction-border), transparent);
}

/* チャート */
.chart-container {
  background: var(--chart-bg);
  border-radius: var(--radius-lg);
  padding: 1.5rem;
  box-shadow: var(--shadow-md);
  margin: 1.5rem 0;
  border: 1px solid var(--chart-border);
}

/* 統計表示 */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.stat-item {
  text-align: center;
  padding: 1.5rem;
  background: var(--card-background);
  border-radius: var(--radius-md);
  border: 1px solid var(--border-color);
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.stat-item::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
}

.stat-item:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.stat-value {
  font-size: 1.75rem;
  font-weight: 800;
  color: var(--primary-color);
  margin-bottom: 0.5rem;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.stat-label {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

/* レスポンシブデザイン */
@media (max-width: 768px) {
  .container {
    padding: 0 0.5rem;
  }
  
  .app-header {
    padding: 1.5rem 0.5rem;
  }
  
  .app-header h1 {
    font-size: 1.5rem;
  }
  
  .card {
    padding: 1rem;
    margin-bottom: 1rem;
  }
  
  .btn-group {
    flex-direction: column;
  }
  
  .btn-group .btn {
    width: 100%;
  }
  
  .grid-cols-2,
  .grid-cols-3 {
    grid-template-columns: 1fr;
  }
  
  .stats-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 480px) {
  .log-item {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
  
  .log-actions {
    width: 100%;
    justify-content: space-between;
  }
}

/* アニメーション */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

.fade-in {
  animation: fadeIn 0.4s ease-out;
}

.slide-in {
  animation: slideIn 0.3s ease-out;
}

/* スクロールバーのカスタマイズ */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--background-color);
}

::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* フォーカス表示の改善 */
*:focus-visible {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
}

/* ダークモード切り替えボタン */
#darkModeToggle {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.3);
  color: white;
  backdrop-filter: blur(10px);
  transition: all 0.2s ease;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  margin-bottom: 20px;
}

#darkModeToggle:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* ダークモード時のボタン */
.dark-mode #darkModeToggle {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.2);
}

.dark-mode #darkModeToggle:hover {
  background: rgba(255, 255, 255, 0.2);
}

/* ダークモード対応 */
@media (prefers-color-scheme: dark) {
  :root {
    --background-color: #0f172a;
    --card-background: #1e293b;
    --text-primary: #f1f5f9;
    --text-secondary: #cbd5e1;
    --text-muted: #64748b;
    --border-color: #334155;
  }
}

/* ダークモード用の予測・チャート色 */
.dark-mode {
  /* ページ全体の色 - より高い優先度で適用 */
  --background-color: #0f172a !important;
  --card-background: #1e293b !important;
  --text-primary: #f1f5f9 !important;
  --text-secondary: #cbd5e1 !important;
  --text-muted: #64748b !important;
  --border-color: #334155 !important;
  
  /* 予測・チャート用の色 */
  --prediction-bg: #0c4a6e !important;
  --prediction-border: #38bdf8 !important;
  --prediction-text: #e0f2fe !important;
  --prediction-text-secondary: #bae6fd !important;
  --chart-awake: #fca5a5 !important;
  --chart-sleep: #93c5fd !important;
  --chart-bg: #1e293b !important;
  --chart-border: #334155 !important;
  
  /* ヘッダーの背景色を調整 */
  --header-bg-start: #1e40af !important;
  --header-bg-end: #059669 !important;
  
  /* ステータス表示の背景色を調整 */
  --status-success-bg: rgba(16, 185, 129, 0.2) !important;
  --status-info-bg: rgba(99, 102, 241, 0.2) !important;
  --status-warning-bg: rgba(245, 158, 11, 0.2) !important;
  
  /* ボタンの色を調整 */
  --btn-outline-color: #60a5fa !important;
  --btn-outline-border: #60a5fa !important;
  --btn-outline-hover-bg: #60a5fa !important;
  --btn-outline-hover-color: #1e293b !important;
}

/* ダークモード時のヘッダー背景 */
.dark-mode .app-header {
  background: linear-gradient(135deg, var(--header-bg-start), var(--header-bg-end));
}

/* ダークモード時のステータス表示 */
.dark-mode .status-success {
  background: var(--status-success-bg);
}

.dark-mode .status-info {
  background: var(--status-info-bg);
}

.dark-mode .status-warning {
  background: var(--status-warning-bg);
}

/* ダークモード時のボタン */
.dark-mode .btn-outline {
  color: var(--btn-outline-color);
  border-color: var(--btn-outline-border);
}

.dark-mode .btn-outline:hover {
  background: var(--btn-outline-hover-bg);
  color: var(--btn-outline-hover-color);
}

/* details要素のスタイリング */
details summary {
  cursor: pointer;
  padding: 0.5rem;
  background: var(--background-color);
  border-radius: var(--radius-md);
  color: var(--text-secondary);
  transition: all 0.2s ease;
}

details summary:hover {
  background: var(--border-color);
}

details > div {
  background: var(--background-color);
  margin-top: 0.5rem;
}

/* ダークモード時のdetails要素 */
.dark-mode details summary {
  background: var(--card-background);
  color: var(--text-secondary);
}

.dark-mode details summary:hover {
  background: var(--border-color);
}

/* ダークモード時のdetails内容 */
.dark-mode details > div {
  background: var(--card-background);
}

/* ダークモード時の統計表示 */
.dark-mode .stat-item {
  background: var(--card-background);
}

/* ダークモード時の統計値の色 */
.dark-mode .stat-value {
  color: var(--primary-color);
}

/* ダークモード時の統計ラベルの色 */
.dark-mode .stat-label {
  color: var(--text-secondary);
}

/* ダークモード時の予測カードの改善 */
.dark-mode .prediction-card {
  box-shadow: 0 4px 6px -1px rgba(56, 189, 248, 0.2), 0 2px 4px -2px rgba(56, 189, 248, 0.2);
}

.dark-mode .prediction-card::before {
  background: linear-gradient(90deg, var(--prediction-border), #60a5fa);
}

.dark-mode .prediction-item:hover {
  background: rgba(56, 189, 248, 0.1);
}

.dark-mode .prediction-item:not(:last-child)::after {
  background: linear-gradient(to bottom, transparent, var(--prediction-border), transparent);
}

/* ダークモード時の予測統計の背景 */
.dark-mode .card .card {
  background: var(--card-background);
}

/* ダークモード時の予測統計のボーダー */
.dark-mode .card .card {
  border-color: var(--border-color);
}

/* ダークモード時の動的生成要素 */
.dark-mode .log-item .log-time {
  color: var(--text-primary);
}

.dark-mode .log-item .log-type {
  color: var(--text-secondary);
}

/* ダークモード時の予測統計の説明文背景 */
.dark-mode .prediction-stats-info {
  background: var(--card-background) !important;
  color: var(--text-secondary) !important;
  border-color: var(--border-color) !important;
}

/* 月齢情報表示 */
.months-info {
  text-align: center;
  margin-top: 1rem;
  padding: 0.75rem;
  background: rgba(99, 102, 241, 0.15);
  border-radius: var(--radius-md);
  color: var(--primary-color);
  font-size: 0.9rem;
  font-weight: 600;
  border: 1px solid rgba(99, 102, 241, 0.2);
}

/* 予測統計の説明文背景 */
.prediction-stats-info {
  margin-top: 1rem;
  padding: 1rem;
  background: rgba(16, 185, 129, 0.15);
  border-radius: var(--radius-md);
  border-left: 4px solid var(--secondary-color);
  color: var(--secondary-color);
  font-weight: 600;
}

/* 睡眠パターンの傾向表示 */
.pattern-trend-info {
  margin-top: 1rem;
  padding: 1rem;
  background: var(--background-color);
  border-radius: var(--radius-md);
  border-left: 4px solid var(--accent-color);
}

/* ダークモード時の月齢情報表示 */
.dark-mode .months-info {
  background: rgba(99, 102, 241, 0.2) !important;
  border-color: rgba(99, 102, 241, 0.4) !important;
}

/* ダークモード時の予測統計の説明文背景 */
.dark-mode .prediction-stats-info {
  background: rgba(16, 185, 129, 0.2) !important;
  border-color: var(--secondary-color) !important;
}

/* ダークモード時の予測統計の傾向表示 */
.dark-mode .pattern-trend-info {
  background: var(--card-background) !important;
  border-color: var(--accent-color) !important;
}
</style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js?v=20250810-1"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.umd.min.js?v=20250810-1"></script>
</head>
<body>

<div class="app-header">
  <h1>🌙 ベビースリープ予測</h1>
  <div class="subtitle">赤ちゃんの睡眠パターンを記録・予測</div>
</div>
  
<div class="container">
  <!-- クイックアクション -->
  <div class="card">
    <div class="card-header">
      <span class="icon">⚡</span>
      <h3>クイックアクション</h3>
    </div>
    <div class="btn-group">
      <button class="btn btn-primary" onclick="addLog('wake')">
        <span>🌅</span>
        起きた
      </button>
      <button class="btn btn-secondary" onclick="addLog('nap')">
        <span>😴</span>
        寝た
      </button>
    </div>
  </div>

    <!-- 予測表示 -->
    <div class="card prediction-card">
      <div class="card-header">
        <span class="icon">🔮</span>
        <h3>次の寝かしつけ予測</h3>
      </div>
  <div id="prediction"></div>
    </div>
  
  
  <!-- 時間指定で追加・編集 -->
  <div class="card">
    <div class="card-header">
      <span class="icon">⏰</span>
      <h3>時間指定で追加・編集</h3>
    </div>
    <div class="grid grid-cols-3">
      <div class="form-group">
        <label class="form-label">タイプ</label>
        <select id="typeSelect" class="form-control">
      <option value="wake">起きた</option>
      <option value="nap">寝た</option>
    </select>
      </div>
      <div class="form-group">
        <label class="form-label">時刻</label>
        <input id="timeInput" type="time" step="60" class="form-control">
      </div>
      <div class="form-group">
        <div class="btn-group">
          <button id="addBtn" class="btn btn-primary" onclick="handleAddOrUpdate()">追加</button>
          <button id="cancelEditBtn" class="btn btn-outline" onclick="cancelEdit()" style="display:none;">キャンセル</button>
        </div>
      </div>
    </div>
    <div id="editStatus" class="status status-info" style="display:none;"></div>
  </div>

  <!-- 記録表示 -->
  <div class="card">
    <div class="card-header">
      <span class="icon">📝</span>
      <h3>記録</h3>
    </div>
<div id="log"></div>
  </div>

  
  <!-- 表示日設定 -->
  <div class="card">
    <div class="card-header">
      <span class="icon">📅</span>
      <h3>表示日</h3>
    </div>
    <div class="grid grid-cols-4">
      <div class="form-group">
        <input id="viewDate" type="date" class="form-control">
      </div>
      <div class="form-group">
        <button class="btn btn-accent" onclick="goToday()">今日</button>
        <button class="btn btn-outline" onclick="shiftDay(-1)">前日</button>
        <button class="btn btn-outline" onclick="shiftDay(1)">翌日</button>
      </div>
    </div>
    <div id="viewDateStatus" class="status status-info"></div>
  </div>

  <!-- タイムラインチャート -->
  <div class="chart-container">
    <div class="card-header">
      <span class="icon">📊</span>
      <h3>睡眠タイムライン</h3>
    </div>
<canvas id="timelineChart" height="150"></canvas>
  </div>

    <!-- 生年月日設定 -->
    <div class="card">
      <div class="card-header">
        <span class="icon">🎂</span>
        <h3>生年月日</h3>
      </div>
      <div class="grid grid-cols-2">
        <div class="form-group">
          <input id="birthInput" type="date" class="form-control">
        </div>
        <div class="form-group">
          <button class="btn btn-secondary" onclick="saveBirth()">保存</button>
        </div>
      </div>
      <br>
      <div id="birthStatus" class="status status-info"></div>
    </div>
  

  <!-- ぴよログインポート -->
  <div class="card">
    <div class="card-header">
      <span class="icon">📁</span>
      <h3>ぴよログからインポート</h3>
    </div>
    <div class="grid grid-cols-2">
      <div class="form-group">
        <input id="piyoFile" type="file" accept=".txt" class="form-control">
      </div>
      <div class="form-group">
        <button class="btn btn-secondary" onclick="handleImportPiyolog()">インポート</button>
      </div>
    </div>
    <div id="importStatus" class="status status-info"></div>
    <div style="color:var(--text-muted); font-size:0.9em; margin-top:0.5rem;">
    ファイルに含まれる全ての日の「起きる／寝る」を取り込みます（同日の既存記録は上書き）。
  </div>
</div>

  <!-- CSVエクスポート -->
  <div class="card">
    <div class="card-header">
      <span class="icon">💾</span>
      <h3>CSVエクスポート</h3>
    </div>
    <button class="btn btn-primary" onclick="exportSleepData()">
      <span>📊</span>
      睡眠データをエクスポート
    </button>
    <div id="analysisStatus" class="status status-info" style="margin-top:0.5rem;"></div>
  </div>

  <button id="darkModeToggle" class="btn btn-outline" style="background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.3); color: white; backdrop-filter: blur(10px); z-index: 1000;">
    🌙
  </button>
</div>

<script>
// データ構造を日付ごとの辞書に移行（互換: 旧配列→今日の日付に移行）
let allLogsRaw = null;
try {
  allLogsRaw = JSON.parse(localStorage.getItem('babyLogs') || 'null');
} catch (_) {
  allLogsRaw = null;
}

function __computeTodayKey() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}/${m}/${day}`;
}

let allLogs = {};
if (Array.isArray(allLogsRaw)) {
  // 旧形式（配列）→ 今日の日付に移し替え
  const todayKey = __computeTodayKey();
  allLogs[todayKey] = allLogsRaw.filter(l => l && (l.type === 'wake' || l.type === 'nap'));
} else if (allLogsRaw && typeof allLogsRaw === 'object') {
  allLogs = allLogsRaw;
  // 各日ごとに型フィルタを適用
  for (const k of Object.keys(allLogs)) {
    const arr = Array.isArray(allLogs[k]) ? allLogs[k] : [];
    allLogs[k] = arr.filter(l => l && (l.type === 'wake' || l.type === 'nap'));
  }
} else {
  const todayKey = __computeTodayKey();
  allLogs[todayKey] = [];
}
localStorage.setItem('babyLogs', JSON.stringify(allLogs));

let currentDateKey = __computeTodayKey();
let logs = allLogs[currentDateKey] || [];
let timelineChart = null;
let editingIndex = null;
const BIRTH_KEY = "babyBirthDate"; // YYYY-MM-DD で保存

function nowTimeString() {
  const now = new Date();
  const hh = String(now.getHours()).padStart(2, '0');
  const mm = String(now.getMinutes()).padStart(2, '0');
  return `${hh}:${mm}`;
}

function getSortKey(timeStr) {
  const [h, m] = timeStr.split(":").map(Number);
  // 07:00を日境界にし、<07:00 は翌日扱い
  const minutes = h * 60 + m;
  return minutes < 7 * 60 ? minutes + 24 * 60 : minutes;
}

function sortLogs() {
  logs.sort((a, b) => getSortKey(a.time) - getSortKey(b.time));
}

function saveAllLogs() {
  localStorage.setItem('babyLogs', JSON.stringify(allLogs));
}

function setCurrentDateKey(newKey) {
  currentDateKey = newKey;
  if (!allLogs[currentDateKey]) allLogs[currentDateKey] = [];
  // 型フィルタ
  allLogs[currentDateKey] = allLogs[currentDateKey].filter(l => l && (l.type === 'wake' || l.type === 'nap'));
  logs = allLogs[currentDateKey];
  sortLogs();
  saveAllLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  updateViewDateStatus();
  // 予測精度統計を更新
  showPredictionStats();
}

function keyFromInputValue(value) { // YYYY-MM-DD -> YYYY/MM/DD
  if (!value) return null;
  const [y, m, d] = value.split('-');
  return `${y}/${m}/${d}`;
}

function inputValueFromKey(key) { // YYYY/MM/DD -> YYYY-MM-DD
  if (!key) return '';
  const [y, m, d] = key.split('/');
  return `${y}-${m}-${d}`;
}

function goToday() {
  setCurrentDateKey(__computeTodayKey());
  const viewDateEl = document.getElementById('viewDate');
  if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);
}

function shiftDay(delta) {
  const [y, m, d] = currentDateKey.split('/').map(Number);
  const dt = new Date(y, m - 1, d);
  dt.setDate(dt.getDate() + delta);
  const key = `${dt.getFullYear()}/${String(dt.getMonth() + 1).padStart(2, '0')}/${String(dt.getDate()).padStart(2, '0')}`;
  setCurrentDateKey(key);
  const viewDateEl = document.getElementById('viewDate');
  if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);
}

function updateViewDateStatus() {
  const status = document.getElementById('viewDateStatus');
  if (!status) return;
  status.textContent = `表示中: ${currentDateKey}（${logs.length}件）`;
}

function addLog(type) {
  const time = nowTimeString();
  addLogAt(type, time);
}

function addLogAt(type, time) {
  if (!time || !/^\d{2}:\d{2}$/.test(time)) {
    alert('時刻は HH:MM 形式で指定してください');
    return;
  }
  if (!(type === 'wake' || type === 'nap')) {
    alert('追加できるのは「起きた」「寝た」のみです');
    return;
  }
  logs.push({ type, time });
  sortLogs();
  allLogs[currentDateKey] = logs;
  saveAllLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  // 予測精度統計を更新
  showPredictionStats();
}

function startEditLog(index) {
  const target = logs[index];
  if (!target) return;
  editingIndex = index;
  document.getElementById('typeSelect').value = target.type;
  document.getElementById('timeInput').value = target.time;
  const addBtn = document.getElementById('addBtn');
  addBtn.textContent = '更新';
  document.getElementById('cancelEditBtn').style.display = '';
  document.getElementById('editStatus').textContent = `編集中: ${target.time} - ${translateType(target.type)}`;
}

function handleAddOrUpdate() {
  const type = document.getElementById('typeSelect').value;
  const time = document.getElementById('timeInput').value;
  if (!time || !/^\d{2}:\d{2}$/.test(time)) {
    alert('時刻は HH:MM 形式で指定してください');
    return;
  }
  if (editingIndex === null) {
    addLogAt(type, time);
  } else {
    logs[editingIndex] = { type, time };
    sortLogs();
    allLogs[currentDateKey] = logs;
    saveAllLogs();
    renderLogs();
    updateTimelineChart();
    updatePrediction();
    // 予測精度統計を更新
    showPredictionStats();
    cancelEdit();
  }
}

function cancelEdit() {
  editingIndex = null;
  const addBtn = document.getElementById('addBtn');
  addBtn.textContent = 'この時間で追加';
  document.getElementById('cancelEditBtn').style.display = 'none';
  document.getElementById('editStatus').textContent = '';
  const timeInputEl = document.getElementById('timeInput');
  if (timeInputEl) timeInputEl.value = nowTimeString();
}

function deleteLog(index) {
  const target = logs[index];
  if (!target) return;
  const ok = confirm(`削除しますか？\n${target.time} - ${translateType(target.type)}`);
  if (!ok) return;
  logs.splice(index, 1);
  allLogs[currentDateKey] = logs;
  saveAllLogs();
  sortLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  // 予測精度統計を更新
  showPredictionStats();
  cancelEdit();
}

function renderLogs() {
  const container = document.getElementById("log");
  const total = logs.length;
  const recentCount = 3;
  
  if (total === 0) {
    container.innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">📝</div>
        <div>まだ記録がありません</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">「起きた」または「寝た」ボタンを押して記録を開始してください</div>
      </div>
    `;
    return;
  }

  if (total <= recentCount) {
    const allHtml = logs.map((l, i) => {
      return createLogItemHtml(l, i);
    }).join('');
    container.innerHTML = allHtml;
    return;
  }

  const olderCount = total - recentCount;
  const recentBaseIndex = total - recentCount;

  const olderHtml = logs.slice(0, olderCount).map((l, i) => {
    const idx = i;
    return createLogItemHtml(l, idx);
  }).join('');

  const recentHtml = logs.slice(recentBaseIndex).map((l, i) => {
    const idx = recentBaseIndex + i;
    return createLogItemHtml(l, idx);
  }).join('');

  const detailsHtml = `
    <details style="margin-bottom: 1rem;">
      <summary style="cursor: pointer; padding: 0.5rem; border-radius: var(--radius-md);">
        📚 過去の記録を表示（${olderCount}件）
      </summary>
      <div style="margin-top: 0.5rem;">
        ${olderHtml || '<div style="text-align: center; color: var(--text-muted); padding: 1rem;">記録がありません</div>'}
      </div>
    </details>
  `;

  container.innerHTML = detailsHtml + recentHtml;
}

function createLogItemHtml(log, index) {
  const typeClass = log.type === 'wake' ? 'wake' : 'nap';
  const typeIcon = log.type === 'wake' ? '🌅' : '😴';
  const typeText = translateType(log.type);
  
  return `
    <div class="log-item ${typeClass} slide-in">
      <div>
        <div class="log-time">${log.time}</div>
        <div class="log-type">${typeIcon} ${typeText}</div>
      </div>
      <div class="log-actions">
        <button class="btn btn-sm btn-outline" onclick="startEditLog(${index})">
          ✏️ 編集
        </button>
        <button class="btn btn-sm btn-danger" onclick="deleteLog(${index})">
          🗑️ 削除
        </button>
      </div>
    </div>
  `;
}

function translateType(type) {
  return type === "wake" ? "起きた" :
         type === "nap" ? "寝た" : type;
}

// 生年月日の保存・読込と月齢ベースの推定
function saveBirth(showSavedMessage = true) {
  const input = document.getElementById('birthInput');
  const status = document.getElementById('birthStatus');
  if (!input || !status) return;
  const value = input.value; // YYYY-MM-DD or ''
  if (!value) {
    localStorage.removeItem(BIRTH_KEY);
    status.textContent = '未設定';
    updatePrediction();
    return;
  }
  // 簡易バリデーション
  if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) {
    status.textContent = '日付形式が不正です (YYYY-MM-DD)';
    return;
  }
  localStorage.setItem(BIRTH_KEY, value);
  const birth = loadBirth();
  const months = birth ? calculateMonthsAge(birth) : null;
  status.textContent = months !== null ? `保存しました（月齢: ${months}ヶ月）` : '保存しました';
  if (!showSavedMessage) {
    // 即時保存時は控えめな表示
    status.textContent = months !== null ? `保存済み（月齢: ${months}ヶ月）` : '保存済み';
  }
  updatePrediction();
}

function loadBirth() {
  const stored = localStorage.getItem(BIRTH_KEY);
  if (!stored) return null;
  // Local 00:00 に設定
  const [y, m, d] = stored.split('-').map(Number);
  const dt = new Date();
  dt.setHours(0, 0, 0, 0);
  dt.setFullYear(y, m - 1, d);
  return isNaN(dt.getTime()) ? null : dt;
}

function calculateMonthsAge(birthDate, refDate = new Date()) {
  if (!birthDate) return null;
  const y1 = birthDate.getFullYear();
  const m1 = birthDate.getMonth();
  const d1 = birthDate.getDate();
  const y2 = refDate.getFullYear();
  const m2 = refDate.getMonth();
  const d2 = refDate.getDate();
  let months = (y2 - y1) * 12 + (m2 - m1);
  if (d2 < d1) months -= 1; // 当月の誕生日未到達なら-1
  return Math.max(0, months);
}

function getAwakeWindowByMonths(monthsAge) {
  // 参考レンジ（分）: 文献や一般的な目安に基づく緩めの範囲
  if (monthsAge === null) return [120, 150];
  if (monthsAge <= 2) return [45, 90];
  if (monthsAge <= 4) return [75, 120];
  if (monthsAge <= 6) return [90, 150];
  if (monthsAge <= 8) return [120, 180];
  if (monthsAge <= 10) return [150, 210];
  if (monthsAge <= 12) return [180, 240];
  return [210, 300];
}

function getNapLengthByMonths(monthsAge, nextNapStart) {
  const hour = nextNapStart.getHours();
  // 基本レンジ（分）
  let minMax;
  if (monthsAge === null) {
    minMax = [60, 90];
  } else if (monthsAge <= 2) {
    minMax = [60, 120];
  } else if (monthsAge <= 4) {
    minMax = [60, 120];
  } else if (monthsAge <= 6) {
    minMax = [60, 90];
  } else if (monthsAge <= 8) {
    minMax = [45, 90];
  } else if (monthsAge <= 12) {
    minMax = [45, 90];
  } else {
    minMax = [45, 60];
  }
  let nap = randomIntInclusive(minMax[0], minMax[1]);
  // 15時以降は短めに制限
  if (hour >= 15) {
    nap = Math.min(nap, 45);
  }
  return nap;
}

function randomIntInclusive(min, max) {
  const mn = Math.ceil(min);
  const mx = Math.floor(max);
  return Math.floor(Math.random() * (mx - mn + 1)) + mn;
}

function updatePrediction() {
  if (logs.length === 0) {
    document.getElementById("prediction").innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">🔮</div>
        <div>この日の起床ログ後に予測が表示されます</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">「起きた」ボタンを押して記録を開始してください</div>
      </div>
    `;
    return;
  }
  // 直近の「状態」ログ（wake/nap）のみを見る。
  const lastStateIndex = [...logs].map((l, i) => ({...l, i}))
    .filter(l => l.type === 'wake' || l.type === 'nap')
    .map(l => l.i)
    .pop();
  if (lastStateIndex === undefined) {
    document.getElementById("prediction").innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">🔮</div>
        <div>この日の起床ログ後に予測が表示されます</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">「起きた」ボタンを押して記録を開始してください</div>
      </div>
    `;
    return;
  }
  const lastState = logs[lastStateIndex];
  if (lastState.type !== 'wake') {
    document.getElementById("prediction").innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">🔮</div>
        <div>この日の起床ログ後に予測が表示されます</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">現在は睡眠中のようです</div>
      </div>
    `;
    return;
  }

  const [h, m] = lastState.time.split(":").map(Number);
  const wakeTime = new Date();
  wakeTime.setHours(h, m);

  const birthDate = loadBirth();
  const monthsAge = birthDate ? calculateMonthsAge(birthDate, new Date()) : null;

  // 過去データベースの予測を取得
  const historicalPrediction = getHistoricalPrediction(wakeTime, monthsAge);
  
  // 月齢ベースの基本予測
  const [awakeMin, awakeMax] = getAwakeWindowByMonths(monthsAge);
  const basicAwakeMinutes = randomIntInclusive(awakeMin, awakeMax);
  const basicNextNapStart = new Date(wakeTime.getTime() + basicAwakeMinutes * 60000);
  const basicNapLengthMinutes = getNapLengthByMonths(monthsAge, basicNextNapStart);

  // 過去データと基本予測を組み合わせた最終予測
  let finalAwakeMinutes, finalNapLengthMinutes;
  if (historicalPrediction) {
    // 過去データがある場合は、基本予測と過去データを重み付けで組み合わせ
    const historicalWeight = 0.7; // 過去データの重み
    const basicWeight = 0.3; // 基本予測の重み
    
    finalAwakeMinutes = Math.round(
      historicalPrediction.avgAwakeTime * historicalWeight + 
      basicAwakeMinutes * basicWeight
    );
    finalNapLengthMinutes = Math.round(
      historicalPrediction.avgNapLength * historicalWeight + 
      basicNapLengthMinutes * basicWeight
    );
  } else {
    // 過去データがない場合は基本予測を使用
    finalAwakeMinutes = basicAwakeMinutes;
    finalNapLengthMinutes = basicNapLengthMinutes;
  }

  const nextNapStart = new Date(wakeTime.getTime() + finalAwakeMinutes * 60000);
  const wakeUpTime = new Date(nextNapStart.getTime() + finalNapLengthMinutes * 60000);

  const monthsInfo = monthsAge !== null ? `月齢: ${monthsAge}ヶ月` : "";
  const historicalInfo = historicalPrediction ? 
    `<small style="color:#666;">過去データベース: 覚醒時間 ${Math.round(historicalPrediction.avgAwakeTime)}分、睡眠時間 ${Math.round(historicalPrediction.avgNapLength)}分</small>` : "";

  document.getElementById("prediction").innerHTML = `
    <div class="grid grid-cols-3">
      <div class="prediction-item">
        <div class="prediction-label">寝かしつけ目安</div>
        <div class="prediction-time">${formatTime(nextNapStart)}</div>
        <div style="font-size: 0.8rem; color: var(--text-muted);">ごろベッドに</div>
      </div>
      <div class="prediction-item">
        <div class="prediction-label">入眠予測</div>
        <div class="prediction-time">${formatTime(new Date(nextNapStart.getTime() + 5*60000))}</div>
        <div style="font-size: 0.8rem; color: var(--text-muted);">約5分後</div>
      </div>
      <div class="prediction-item">
        <div class="prediction-label">起床予測</div>
        <div class="prediction-time">${formatTime(wakeUpTime)}</div>
        <div style="font-size: 0.8rem; color: var(--text-muted);">睡眠時間 ${Math.round(finalNapLengthMinutes)}分</div>
      </div>
    </div>
    ${monthsInfo ? `<div class="months-info">${monthsInfo}</div>` : ''}
    ${historicalInfo ? `<div class="prediction-stats-info">${historicalInfo}</div>` : ''}
  `;
}

function formatTime(date) {
  return date.toTimeString().slice(0,5);
}

function updateTimelineChart() {
  const isDateAdapterReady = () => {
    const a = Chart && Chart._adapters && Chart._adapters._date;
    return !!(a && a.format && a.parse && a.add && a.diff && a.startOf && a.endOf && a.formats);
  };
  // 表示日の 07:00 を軸
  const [y, m, d] = currentDateKey.split('/').map(Number);
  const baseStart = new Date(y, m - 1, d, 7, 0, 0, 0);
  const baseStartMs = baseStart.getTime();
  const rangeDays = 7; // 常に1週間表示

  // 週表示: 各日を縦に並べ、X軸は24時間（7:00→翌7:00）で揃える
  const dayLabels = [];
  const awakeData = [];
  const sleepData = [];

  const labelForDate = (dt) => {
    const w = ['日','月','火','水','木','金','土'];
    return `${String(dt.getMonth()+1).padStart(2,'0')}/${String(dt.getDate()).padStart(2,'0')}(${w[dt.getDay()]})`;
  };

  const generateDayEvents = (dt) => {
    const dayStart = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), 7, 0, 0, 0);
    const dayStartMs = dayStart.getTime();
    const dayEndMs = dayStartMs + 24 * 3600000;

    // 前日/当日/翌日のログからシーケンスを作成
    const seq = [];
    for (const off of [-1, 0, 1]) {
      const t = new Date(dt);
      t.setDate(t.getDate() + off);
      const key = `${t.getFullYear()}/${String(t.getMonth()+1).padStart(2,'0')}/${String(t.getDate()).padStart(2,'0')}`;
      const arr = (allLogs[key] || []).filter(l => l.type === 'wake' || l.type === 'nap')
        .sort((a,b)=>getSortKey(a.time)-getSortKey(b.time));
      for (const l of arr) {
        const [hh, mm] = l.time.split(':').map(Number);
        const base = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 7, 0, 0, 0);
        const abs = new Date(base);
        if (hh < 7) abs.setDate(abs.getDate() + 1);
        abs.setHours(hh, mm, 0, 0);
        seq.push({ type: l.type, date: abs });
      }
    }
    seq.sort((a,b)=>a.date.getTime()-b.date.getTime());

    // 連続ペアから当日ウィンドウにクリップしてイベント化
    const evs = [];
    for (let i = 0; i < seq.length - 1; i++) {
      let start = seq[i].date.getTime();
      let end = seq[i+1].date.getTime();
      if (end <= dayStartMs || start >= dayEndMs) continue;
      if (start < dayStartMs) start = dayStartMs;
      if (end > dayEndMs) end = dayEndMs;
      const label = seq[i].type === 'nap' ? '睡眠' : '覚醒';
      const color = seq[i].type === 'nap' ? getComputedStyle(document.documentElement).getPropertyValue('--chart-sleep').trim() : getComputedStyle(document.documentElement).getPropertyValue('--chart-awake').trim();
      evs.push({ label, start: new Date(start), end: new Date(end), color, dayStartMs });
    }
    return { evs, dayStartMs };
  };

  for (let i = 0; i < rangeDays; i++) {
    const dt = new Date(y, m - 1, d);
    dt.setDate(dt.getDate() + i);
    const dayLabel = rangeDays === 1 ? 'スケジュール' : labelForDate(dt);
    if (rangeDays > 1) dayLabels.push(dayLabel);

    const { evs, dayStartMs } = generateDayEvents(dt);
    for (const ev of evs) {
      // 週表示では全日のX軸を同じ24hに揃えるため、基準日の 7:00 を0としてオフセット化
      const offsetStart = ev.start.getTime() - dayStartMs;
      const offsetEnd = ev.end.getTime() - dayStartMs;
      const plotStart = new Date(baseStartMs + offsetStart);
      const plotEnd = new Date(baseStartMs + offsetEnd);
      const dataPoint = { x: [plotStart.getTime(), plotEnd.getTime()], y: dayLabel };
      if (ev.label === '睡眠') sleepData.push(dataPoint); else awakeData.push(dataPoint);
    }
  }

  // 週・日ウィンドウは seq からのイベント生成で全てカバーするため、
  // 追加の持ち越し/翌日延長ロジックは不要。

  const ctx = document.getElementById('timelineChart').getContext('2d');
  if (timelineChart) timelineChart.destroy();

  // 常に1週間表示に固定

  const baseConfig = {
    type: 'bar',
    data: {
      labels: dayLabels,
      datasets: [
        {
          label: '覚醒中',
          data: awakeData,
          backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--chart-awake').trim(),
          borderSkipped: false,
          barPercentage: 0.9,
          categoryPercentage: 1.0,
          grouped: false
        },
        {
          label: '睡眠中',
          data: sleepData,
          backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--chart-sleep').trim(),
          borderSkipped: false,
          barPercentage: 0.9,
          categoryPercentage: 1.0,
          grouped: false
        }
      ]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      plugins: { legend: { display: true } },
      scales: { x: {} }
    }
  };

  const windowStart = baseStartMs;
  const windowEnd = baseStartMs + 24 * 3600000;
  const timeseriesX = {
    type: 'timeseries',
    time: { unit: 'hour', displayFormats: { hour: 'HH:mm' } },
    min: new Date(windowStart),
    max: new Date(windowEnd)
  };
  const linearX = {
    type: 'linear',
    min: windowStart,
    max: windowEnd,
    ticks: { callback: (value) => formatTime(new Date(value)) }
  };

  try {
    baseConfig.options.scales.x = isDateAdapterReady() ? timeseriesX : linearX;
    timelineChart = new Chart(ctx, baseConfig);
  } catch (err) {
    console.warn('Chart init failed, fallback to linear scale:', err);
    baseConfig.options.scales.x = linearX;
    timelineChart = new Chart(ctx, baseConfig);
  }
}

// ぴよログ取り込み
function handleImportPiyolog() {
  const input = document.getElementById('piyoFile');
  const status = document.getElementById('importStatus');
  if (!input || !input.files || input.files.length === 0) {
    status.textContent = 'ファイルを選択してください';
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const text = String(reader.result || '');
      const parsed = parsePiyologTextMulti(text);
      const keys = Object.keys(parsed);
      if (keys.length === 0) {
        status.textContent = '取り込める記録が見つかりませんでした';
        return;
      }
      // 各日を上書き保存
      for (const k of keys) {
        const items = parsed[k].filter(l => l && (l.type === 'wake' || l.type === 'nap'));
        allLogs[k] = items;
      }
      saveAllLogs();
      // 最終日のキーに移動
      const latestKey = keys.sort((a, b) => parseDateKey(a) - parseDateKey(b))[keys.length - 1];
      setCurrentDateKey(latestKey);
      status.textContent = `インポート完了（${keys.length}日 / 最終日: ${latestKey}）`;
    } catch (e) {
      console.error(e);
      status.textContent = 'インポート中にエラーが発生しました';
    }
  };
  reader.onerror = () => {
    status.textContent = 'ファイルの読み込みに失敗しました';
  };
  reader.readAsText(file, 'utf-8');
}

function parsePiyologText(text) {
  const lines = text.split(/\r?\n/);
  const dateHeaderRegex = /^\s*(\d{4})\/(\d{1,2})\/(\d{1,2})\s*\(/;
  const timeLineRegex = /^\s*(\d{2}):(\d{2})\s+(.+)/;

  /** @type {Record<string, Array<{time: string, type: 'wake'|'nap'}>>} */
  const dateToItems = {};
  let currentDateKey = null;

  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const dh = dateHeaderRegex.exec(line);
    if (dh) {
      const y = dh[1].padStart(4, '0');
      const m = dh[2].padStart(2, '0');
      const d = dh[3].padStart(2, '0');
      currentDateKey = `${y}/${m}/${d}`;
      if (!dateToItems[currentDateKey]) dateToItems[currentDateKey] = [];
      continue;
    }
    if (!currentDateKey) continue;
    const tl = timeLineRegex.exec(line);
    if (!tl) continue;
    const hh = tl[1];
    const mm = tl[2];
    const body = tl[3];
    const time = `${hh}:${mm}`;
    let type = null;
    if (body.startsWith('起きる')) type = 'wake';
    else if (body.startsWith('寝る')) type = 'nap';
    if (type) {
      dateToItems[currentDateKey].push({ time, type });
    }
  }

  const keys = Object.keys(dateToItems);
  if (keys.length === 0) return { dateKey: null, items: [] };
  const latestKey = keys.sort((a, b) => parseDateKey(a) - parseDateKey(b))[keys.length - 1];
  return { dateKey: latestKey, items: dateToItems[latestKey] };
}

function parseDateKey(key) {
  // key: YYYY/MM/DD
  const [y, m, d] = key.split('/').map(Number);
  const dt = new Date();
  dt.setHours(0, 0, 0, 0);
  dt.setFullYear(y, m - 1, d);
  return dt.getTime();
}

// 複数日を返す版
function parsePiyologTextMulti(text) {
  const lines = text.split(/\r?\n/);
  const dateHeaderRegex = /^\s*(\d{4})\/(\d{1,2})\/(\d{1,2})\s*\(/;
  const timeLineRegex = /^\s*(\d{2}):(\d{2})\s+(.+)/;
  /** @type {Record<string, Array<{time: string, type: 'wake'|'nap'}>>} */
  const dateToItems = {};
  let currentDateKey = null;
  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const dh = dateHeaderRegex.exec(line);
    if (dh) {
      const y = dh[1].padStart(4, '0');
      const m = dh[2].padStart(2, '0');
      const d = dh[3].padStart(2, '0');
      currentDateKey = `${y}/${m}/${d}`;
      if (!dateToItems[currentDateKey]) dateToItems[currentDateKey] = [];
      continue;
    }
    if (!currentDateKey) continue;
    const tl = timeLineRegex.exec(line);
    if (!tl) continue;
    const hh = tl[1];
    const mm = tl[2];
    const body = tl[3];
    const time = `${hh}:${mm}`;
    let type = null;
    if (body.startsWith('起きる')) type = 'wake';
    else if (body.startsWith('寝る')) type = 'nap';
    if (type) {
      dateToItems[currentDateKey].push({ time, type });
    }
  }
  return dateToItems;
}

// 過去データベースの予測を取得する関数
function getHistoricalPrediction(currentWakeTime, monthsAge) {
  const allDates = Object.keys(allLogs).sort();
  if (allDates.length < 3) return null; // 最低3日分のデータが必要

  const currentDate = new Date();
  const currentHour = currentWakeTime.getHours();
  
  // 過去30日分のデータを分析
  const analysisDays = 30;
  const recentDates = allDates.slice(-analysisDays);
  
  let totalAwakeTime = 0;
  let totalNapLength = 0;
  let validPatterns = 0;

  for (const dateKey of recentDates) {
    const dayLogs = allLogs[dateKey] || [];
    if (dayLogs.length < 2) continue;

    // その日の睡眠パターンを分析
    const patterns = analyzeDayPattern(dayLogs, dateKey);
    if (patterns.length === 0) continue;

    // 現在時刻に近い時間帯のパターンを探す
    for (const pattern of patterns) {
      if (pattern.wakeHour >= currentHour - 2 && pattern.wakeHour <= currentHour + 2) {
        totalAwakeTime += pattern.awakeTime;
        totalNapLength += pattern.napLength;
        validPatterns++;
      }
    }
  }

  if (validPatterns < 2) return null; // 最低2パターンのデータが必要

  return {
    avgAwakeTime: totalAwakeTime / validPatterns,
    avgNapLength: totalNapLength / validPatterns,
    dataPoints: validPatterns
  };
}

// 1日の睡眠パターンを分析する関数
function analyzeDayPattern(dayLogs, dateKey) {
  const patterns = [];
  const sortedLogs = dayLogs
    .filter(l => l.type === 'wake' || l.type === 'nap')
    .sort((a, b) => getSortKey(a.time) - getSortKey(b.time));

  for (let i = 0; i < sortedLogs.length - 1; i++) {
    const current = sortedLogs[i];
    const next = sortedLogs[i + 1];
    
    if (current.type === 'wake' && next.type === 'nap') {
      // 覚醒→睡眠のパターン
      const [wakeHour, wakeMin] = current.time.split(':').map(Number);
      const [napHour, napMin] = next.time.split(':').map(Number);
      
      // 覚醒時間を計算
      let awakeTime = (napHour * 60 + napMin) - (wakeHour * 60 + wakeMin);
      if (awakeTime < 0) awakeTime += 24 * 60; // 日をまたぐ場合
      
      // 睡眠時間を計算（次の覚醒まで）
      let napLength = 0;
      if (i + 2 < sortedLogs.length && sortedLogs[i + 2].type === 'wake') {
        const nextWake = sortedLogs[i + 2];
        const [nextWakeHour, nextWakeMin] = nextWake.time.split(':').map(Number);
        napLength = (nextWakeHour * 60 + nextWakeMin) - (napHour * 60 + napMin);
        if (napLength < 0) napLength += 24 * 60;
      } else {
        // 次の覚醒がない場合は推定
        napLength = getNapLengthByMonths(null, new Date());
      }

      patterns.push({
        wakeHour: wakeHour,
        awakeTime: awakeTime,
        napLength: napLength,
        date: dateKey
      });
    }
  }

  return patterns;
}

// 予測精度の評価と統計情報を表示する関数
function showPredictionStats() {
  const allDates = Object.keys(allLogs).sort();
  let statsHtml = '';
  
  if (allDates.length < 3) {
    statsHtml = `
      <div class="card">
        <div class="card-header">
          <span class="icon">📊</span>
        <h3>予測精度統計</h3>
        </div>
        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
          <div style="font-size: 3rem; margin-bottom: 1rem;">📈</div>
          <div>統計分析には最低3日分のデータが必要です</div>
          <div style="font-size: 0.9rem; margin-top: 0.5rem; color: var(--text-secondary);">現在の記録: ${allDates.length}日分</div>
        </div>
      </div>
    `;
  } else {
    const stats = calculatePredictionStats();
    statsHtml = `
      <div class="card">
        <div class="card-header">
          <span class="icon">📊</span>
        <h3>予測精度統計</h3>
          </div>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value">${stats.startDate} 〜 ${stats.endDate}</div>
            <div class="stat-label">データ期間（${stats.totalDays}日間）</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${stats.totalLogs}件</div>
            <div class="stat-label">記録総数（1日平均 ${Math.round(stats.avgLogsPerDay)}件）</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${Math.round(stats.avgAwakeTime)}分</div>
            <div class="stat-label">平均覚醒時間（標準偏差: ±${Math.round(stats.stdAwakeTime)}分）</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${Math.round(stats.avgNapLength)}分</div>
            <div class="stat-label">平均睡眠時間（標準偏差: ±${Math.round(stats.stdNapLength)}分）</div>
        </div>
        </div>
        <div class="pattern-trend-info">
          <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem;">睡眠パターンの傾向</div>
          <div style="color: var(--text-secondary);">${stats.patternTrend}</div>
        </div>
      </div>
    `;
  }

  // 既存の統計表示があれば更新、なければ追加
  const existingStats = document.getElementById('predictionStats');
  if (existingStats) {
    existingStats.innerHTML = statsHtml;
  } else {
    const container = document.createElement('div');
    container.id = 'predictionStats';
    container.innerHTML = statsHtml;
    document.getElementById('timelineChart').after(container);
  }
}

// 予測統計を計算する関数
function calculatePredictionStats() {
  const allDates = Object.keys(allLogs).sort();
  const startDate = allDates[0];
  const endDate = allDates[allDates.length - 1];
  const totalDays = allDates.length;
  
  let totalLogs = 0;
  let totalAwakeTime = 0;
  let totalNapLength = 0;
  let awakeTimes = [];
  let napLengths = [];
  let validPatterns = 0;

  for (const dateKey of allDates) {
    const dayLogs = allLogs[dateKey] || [];
    totalLogs += dayLogs.length;
    
    const patterns = analyzeDayPattern(dayLogs, dateKey);
    for (const pattern of patterns) {
      awakeTimes.push(pattern.awakeTime);
      napLengths.push(pattern.napLength);
      totalAwakeTime += pattern.awakeTime;
      totalNapLength += pattern.napLength;
      validPatterns++;
    }
  }

  const avgAwakeTime = validPatterns > 0 ? totalAwakeTime / validPatterns : 0;
  const avgNapLength = validPatterns > 0 ? totalNapLength / validPatterns : 0;
  
  const stdAwakeTime = calculateStandardDeviation(awakeTimes, avgAwakeTime);
  const stdNapLength = calculateStandardDeviation(napLengths, avgNapLength);

  // 睡眠パターンの傾向を分析
  const patternTrend = analyzePatternTrend(awakeTimes, napLengths);

  return {
    startDate,
    endDate,
    totalDays,
    totalLogs,
    avgLogsPerDay: totalLogs / totalDays,
    avgAwakeTime,
    avgNapLength,
    stdAwakeTime,
    stdNapLength,
    patternTrend
  };
}

// 標準偏差を計算する関数
function calculateStandardDeviation(values, mean) {
  if (values.length < 2) return 0;
  const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
  const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  return Math.sqrt(avgSquaredDiff);
}

// 睡眠パターンの傾向を分析する関数
function analyzePatternTrend(awakeTimes, napLengths) {
  if (awakeTimes.length < 3) return 'データ不足のため傾向を分析できません';

  // 時系列での変化を分析
  const recentAwake = awakeTimes.slice(-Math.floor(awakeTimes.length / 3));
  const earlyAwake = awakeTimes.slice(0, Math.floor(awakeTimes.length / 3));
  
  const recentAvg = recentAwake.reduce((sum, val) => sum + val, 0) / recentAwake.length;
  const earlyAvg = earlyAwake.reduce((sum, val) => sum + val, 0) / earlyAwake.length;
  
  let trend = '';
  if (recentAvg > earlyAvg + 30) {
    trend = '覚醒時間が徐々に長くなっています';
  } else if (recentAvg < earlyAvg - 30) {
    trend = '覚醒時間が徐々に短くなっています';
  } else {
    trend = '覚醒時間は安定しています';
  }

  // 睡眠時間の一貫性
  const napStd = calculateStandardDeviation(napLengths, napLengths.reduce((sum, val) => sum + val, 0) / napLengths.length);
  if (napStd < 30) {
    trend += '<br>睡眠時間は一貫しています';
  } else if (napStd > 60) {
    trend += '<br>睡眠時間にばらつきがあります';
  } else {
    trend += '<br>睡眠時間はややばらつきがあります';
  }

  return trend;
}

// 睡眠データをエクスポートする関数
function exportSleepData() {
  const allDates = Object.keys(allLogs).sort();
  if (allDates.length === 0) {
    alert('エクスポートするデータがありません');
    return;
  }

  let csvContent = '日付,時刻,タイプ\n';
  
  for (const dateKey of allDates) {
    const dayLogs = allLogs[dateKey] || [];
    for (const log of dayLogs) {
      const date = dateKey.replace(/\//g, '-');
      const type = log.type === 'wake' ? '起床' : '睡眠';
      csvContent += `${date},${log.time},${type}\n`;
    }
  }

  // CSVファイルをダウンロード
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', `baby_sleep_data_${new Date().toISOString().split('T')[0]}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // ステータス更新
  const status = document.getElementById('analysisStatus');
  if (status) {
    status.textContent = `エクスポート完了（${allDates.length}日分）`;
    setTimeout(() => { status.textContent = ''; }, 3000);
  }
}



// 既存データからdetailsフィールドを削除（詳細記録機能削除のため）
function cleanupDetailsField() {
  let hasChanges = false;
  for (const dateKey in allLogs) {
    const dayLogs = allLogs[dateKey] || [];
    for (const log of dayLogs) {
      if (log.details !== undefined) {
        delete log.details;
        hasChanges = true;
      }
    }
  }
  if (hasChanges) {
    saveAllLogs();
  }
}

// 初期化
// 表示日初期値を今日に設定し、日付入力にも反映
cleanupDetailsField();
setCurrentDateKey(currentDateKey);
const viewDateEl = document.getElementById('viewDate');
if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);

// 予測精度統計を自動表示
showPredictionStats();

// 時刻入力の初期値を現在時刻に設定
const timeInputEl = document.getElementById('timeInput');
if (timeInputEl) {
  timeInputEl.value = nowTimeString();
}

// 生年月日の初期化
const birthInputEl = document.getElementById('birthInput');
if (birthInputEl) {
  const saved = localStorage.getItem(BIRTH_KEY);
  if (saved) {
    birthInputEl.value = saved;
    const bd = loadBirth();
    if (bd) {
      document.getElementById('birthStatus').textContent = `保存済み（月齢: ${calculateMonthsAge(bd)}ヶ月）`;
    }
  }
  birthInputEl.addEventListener('change', () => {
    // 入力変更で即保存
    saveBirth(false);
  });
}

// 表示日の date 入力変更で切替
const viewDateEl2 = document.getElementById('viewDate');
if (viewDateEl2) {
  viewDateEl2.addEventListener('change', (e) => {
    const v = e.target.value; // YYYY-MM-DD
    if (!v) return;
    const key = v.replace(/-/g, '/');
    setCurrentDateKey(key);
  });
}

// 範囲は固定（1週間）

// ダークモード切り替え機能
function toggleDarkMode() {
  const body = document.body;
  const isDark = body.classList.contains('dark-mode');
  
  if (isDark) {
    // ライトモードに切り替え
    body.classList.remove('dark-mode');
    localStorage.setItem('darkMode', 'light');
    document.getElementById('darkModeToggle').textContent = '🌙';
    
    // 強制的にライトモードの色を適用
    document.documentElement.style.setProperty('--background-color', '#f8fafc');
    document.documentElement.style.setProperty('--card-background', '#ffffff');
    document.documentElement.style.setProperty('--text-primary', '#1e293b');
    document.documentElement.style.setProperty('--text-secondary', '#64748b');
    document.documentElement.style.setProperty('--text-muted', '#94a3b8');
    document.documentElement.style.setProperty('--border-color', '#e2e8f0');
  } else {
    // ダークモードに切り替え
    body.classList.add('dark-mode');
    localStorage.setItem('darkMode', 'dark');
    document.getElementById('darkModeToggle').textContent = '☀️';
    
    // 強制的にダークモードの色を適用
    document.documentElement.style.setProperty('--background-color', '#0f172a');
    document.documentElement.style.setProperty('--card-background', '#1e293b');
    document.documentElement.style.setProperty('--text-primary', '#f1f5f9');
    document.documentElement.style.setProperty('--text-secondary', '#cbd5e1');
    document.documentElement.style.setProperty('--text-muted', '#64748b');
    document.documentElement.style.setProperty('--border-color', '#334155');
  }
  
  // チャートの色を更新
  if (timelineChart) {
    updateTimelineChart();
  }
  
  // 少し遅延させてからページ全体を再描画
  setTimeout(() => {
    // フォームコントロールの色を強制更新
    const formControls = document.querySelectorAll('.form-control');
    formControls.forEach(control => {
      if (isDark) {
        control.style.background = '#ffffff';
        control.style.color = '#1e293b';
      } else {
        control.style.background = '#1e293b';
        control.style.color = '#f1f5f9';
      }
    });
  }, 100);
}

// ダークモードの初期化
function initDarkMode() {
  const savedMode = localStorage.getItem('darkMode');
  
  // ユーザーが明示的に設定した場合は、その設定を優先
  if (savedMode === 'dark') {
    document.body.classList.add('dark-mode');
    document.getElementById('darkModeToggle').textContent = '☀️';
    
    // 強制的にダークモードの色を適用
    document.documentElement.style.setProperty('--background-color', '#0f172a');
    document.documentElement.style.setProperty('--card-background', '#1e293b');
    document.documentElement.style.setProperty('--text-primary', '#f1f5f9');
    document.documentElement.style.setProperty('--text-secondary', '#cbd5e1');
    document.documentElement.style.setProperty('--text-muted', '#64748b');
    document.documentElement.style.setProperty('--border-color', '#334155');
  } else if (savedMode === 'light') {
    document.body.classList.remove('dark-mode');
    document.getElementById('darkModeToggle').textContent = '🌙';
    
    // 強制的にライトモードの色を適用
    document.documentElement.style.setProperty('--background-color', '#f8fafc');
    document.documentElement.style.setProperty('--card-background', '#ffffff');
    document.documentElement.style.setProperty('--text-primary', '#1e293b');
    document.documentElement.style.setProperty('--text-secondary', '#64748b');
    document.documentElement.style.setProperty('--text-muted', '#94a3b8');
    document.documentElement.style.setProperty('--border-color', '#e2e8f0');
  } else {
    // 初回アクセス時のみ、ブラウザの設定を使用
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (prefersDark) {
      document.body.classList.add('dark-mode');
      document.getElementById('darkModeToggle').textContent = '☀️';
      localStorage.setItem('darkMode', 'dark');
      
      // 強制的にダークモードの色を適用
      document.documentElement.style.setProperty('--background-color', '#0f172a');
      document.documentElement.style.setProperty('--card-background', '#1e293b');
      document.documentElement.style.setProperty('--text-primary', '#f1f5f9');
      document.documentElement.style.setProperty('--text-secondary', '#cbd5e1');
      document.documentElement.style.setProperty('--text-muted', '#64748b');
      document.documentElement.style.setProperty('--border-color', '#334155');
    } else {
      localStorage.setItem('darkMode', 'light');
    }
  }
}

// ブラウザの設定変更を監視（ユーザーが設定していない場合のみ）
function watchSystemTheme() {
  const savedMode = localStorage.getItem('darkMode');
  
  // ユーザーが明示的に設定していない場合のみ監視
  if (!savedMode) {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    mediaQuery.addEventListener('change', (e) => {
      // ユーザーがまだ設定していない場合のみ自動変更
      if (!localStorage.getItem('darkMode')) {
        if (e.matches) {
          document.body.classList.add('dark-mode');
          document.getElementById('darkModeToggle').textContent = '☀️';
          localStorage.setItem('darkMode', 'dark');
        } else {
          document.body.classList.remove('dark-mode');
          document.getElementById('darkModeToggle').textContent = '🌙';
          localStorage.setItem('darkMode', 'light');
        }
        
        // チャートの色を更新
        if (timelineChart) {
          updateTimelineChart();
        }
      }
    });
  }
}

// ダークモードボタンのイベントリスナーを設定
document.addEventListener('DOMContentLoaded', () => {
  const darkModeToggle = document.getElementById('darkModeToggle');
  if (darkModeToggle) {
    darkModeToggle.addEventListener('click', toggleDarkMode);
  }
  
  // 初期化
  initDarkMode();
  
  // システムテーマの監視を開始
  watchSystemTheme();
});
</script>

<script>
// PWA Service Worker登録
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js');
}
</script>

</body>
</html>
