<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ãƒ™ãƒ“ãƒ¼ã‚¹ãƒªãƒ¼ãƒ—äºˆæ¸¬</title>
<link rel="manifest" href="./manifest.json">
<style>
/* ãƒ¢ãƒ€ãƒ³ãªã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ */
:root {
  --primary-color: #6366f1;
  --primary-hover: #4f46e5;
  --secondary-color: #10b981;
  --secondary-hover: #059669;
  --accent-color: #f59e0b;
  --accent-hover: #d97706;
  --danger-color: #ef4444;
  --danger-hover: #dc2626;
  --background-color: #f8fafc;
  --card-background: #ffffff;
  --text-primary: #1e293b;
  --text-secondary: #64748b;
  --text-muted: #94a3b8;
  --border-color: #e2e8f0;
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  
  /* äºˆæ¸¬ãƒ»ãƒãƒ£ãƒ¼ãƒˆç”¨ã®æ”¹å–„ã•ã‚ŒãŸè‰² */
  --prediction-bg: #f0f9ff;
  --prediction-border: #0ea5e9;
  --prediction-text: #0c4a6e;
  --prediction-text-secondary: #0369a1;
  --chart-awake: #ef4444;
  --chart-sleep: #3b82f6;
  --chart-bg: #ffffff;
  --chart-border: #e2e8f0;
}

/* ãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ« */
* {
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
  margin: 0;
  padding: 0;
  background: var(--background-color);
  color: var(--text-primary);
  line-height: 1.6;
  font-size: 16px;
}

/* ãƒ˜ãƒƒãƒ€ãƒ¼ */
.app-header {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 50%, var(--accent-color) 100%);
  color: white;
  padding: 2rem 1rem;
  text-align: center;
  margin-bottom: 2rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
}

.app-header::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
  animation: shimmer 3s ease-in-out infinite;
}

@keyframes shimmer {
  0%, 100% { transform: translateX(-100%); }
  50% { transform: translateX(100%); }
}

.app-header h1 {
  margin: 0;
  font-size: 2rem;
  font-weight: 700;
  text-shadow: 0 2px 4px rgba(0,0,0,0.1);
  position: relative;
  z-index: 1;
}

.app-header .subtitle {
  margin-top: 0.5rem;
  opacity: 0.9;
  font-size: 1.1rem;
  position: relative;
  z-index: 1;
}

/* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠ */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}

/* ã‚«ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
.card {
  background: var(--card-background);
  border-radius: var(--radius-lg);
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  box-shadow: var(--shadow-md);
  border: 1px solid var(--border-color);
  transition: all 0.2s ease;
}

.card:hover {
  box-shadow: var(--shadow-lg);
  transform: translateY(-3px);
  border-color: var(--primary-color);
}

.card-header {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 0.75rem;
  border-bottom: 2px solid var(--border-color);
}

.card-header h3 {
  margin: 0;
  color: var(--text-primary);
  font-size: 1.25rem;
  font-weight: 600;
}

.card-header .icon {
  margin-right: 0.75rem;
  font-size: 1.5rem;
  color: var(--primary-color);
}

/* ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  font-weight: 500;
  border: none;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all 0.2s ease;
  text-decoration: none;
  min-height: 44px;
  gap: 0.5rem;
}

.btn-primary {
  background: var(--primary-color);
  color: white;
}

.btn-primary:hover {
  background: var(--primary-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: var(--primary-hover);
}

.btn-secondary {
  background: var(--secondary-color);
  color: white;
}

.btn-secondary:hover {
  background: var(--secondary-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: var(--secondary-hover);
}

.btn-accent {
  background: var(--accent-color);
  color: white;
}

.btn-accent:hover {
  background: var(--accent-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: var(--accent-hover);
}

.btn-danger {
  background: var(--danger-color);
  color: white;
}

.btn-danger:hover {
  background: var(--danger-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: var(--danger-hover);
}

.btn-outline {
  background: transparent;
  color: var(--primary-color);
  border: 2px solid var(--primary-color);
}

.btn-outline:hover {
  background: var(--primary-color);
  color: white;
}

.btn-sm {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  min-height: 36px;
}

.form-label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: var(--text-primary);
}

.form-control {
  width: 100%;
  padding: 0.75rem;
  border: 2px solid var(--border-color);
  border-radius: var(--radius-md);
  font-size: 1rem;
  transition: border-color 0.2s ease;
  background: var(--card-background);
  color: var(--text-primary);
}

.form-control:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
  transform: translateY(-1px);
  transition: all 0.2s ease;
}

.form-control:disabled {
  background: var(--background-color);
  cursor: not-allowed;
}

/* ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ */
select.form-control {
  cursor: pointer;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
  appearance: none;
}

/* ãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ— */
.btn-group {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
  align-items: center;
}

.btn-group .btn {
  flex: 1;
  min-width: 120px;
}

/* ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
.grid {
  display: grid;
  gap: 1.5rem;
}

.grid-cols-1 { grid-template-columns: 1fr; }
.grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
.grid-cols-3 { grid-template-columns: repeat(3, 1fr); }

/* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
.status {
  display: inline-flex;
  align-items: center;
  padding: 0.25rem 0.75rem;
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  font-weight: 500;
}

.status-success {
  background: rgba(16, 185, 129, 0.1);
  color: var(--secondary-color);
}

.status-info {
  background: rgba(99, 102, 241, 0.1);
  color: var(--primary-color);
}

.status-warning {
  background: rgba(245, 158, 11, 0.1);
  color: var(--accent-color);
}

/* ãƒ­ã‚°è¡¨ç¤º */
.log-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  margin-bottom: 0.75rem;
  background: var(--card-background);
  border-radius: var(--radius-md);
  border-left: 4px solid var(--primary-color);
  transition: all 0.2s ease;
  border: 1px solid var(--border-color);
}

.log-item:hover {
  transform: translateX(3px);
  box-shadow: var(--shadow-md);
  border-left-width: 6px;
}

.log-item.wake {
  border-left-color: var(--accent-color);
  background: linear-gradient(135deg, var(--card-background), rgba(245, 158, 11, 0.05));
}

.log-item.nap {
  border-left-color: var(--secondary-color);
  background: linear-gradient(135deg, var(--card-background), rgba(16, 185, 129, 0.05));
}

.log-time {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.1rem;
}

.log-type {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.log-actions {
  display: flex;
  gap: 0.5rem;
}

/* äºˆæ¸¬è¡¨ç¤º */
.prediction-card {
  background: var(--prediction-bg);
  border: 2px solid var(--prediction-border);
  color: var(--prediction-text);
  box-shadow: 0 4px 6px -1px rgba(14, 165, 233, 0.1), 0 2px 4px -2px rgba(14, 165, 233, 0.1);
  position: relative;
  overflow: hidden;
}

.prediction-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, var(--prediction-border), var(--primary-color));
}

.prediction-time {
  font-size: 2rem;
  font-weight: 900;
  color: var(--prediction-text);
  text-align: center;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
  letter-spacing: 0.1em;
  background: linear-gradient(135deg, var(--prediction-text), var(--prediction-text-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.prediction-label {
  font-size: 1rem;
  color: var(--prediction-text-secondary);
  text-align: center;
  margin-bottom: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  opacity: 0.9;
}

.prediction-item {
  text-align: center;
  padding: 1rem;
  position: relative;
  transition: all 0.3s ease;
  border-radius: var(--radius-md);
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border: 1px solid var(--prediction-border);
}

.prediction-item:hover {
  background: rgba(14, 165, 233, 0.15);
  transform: translateY(-3px);
  box-shadow: 0 8px 25px rgba(14, 165, 233, 0.2);
}

.prediction-item:not(:last-child)::after {
  content: '';
  position: absolute;
  right: 0;
  top: 20%;
  bottom: 20%;
  width: 1px;
  background: linear-gradient(to bottom, transparent, var(--prediction-border), transparent);
}

/* ãƒãƒ£ãƒ¼ãƒˆ */
.chart-container {
  background: var(--chart-bg);
  border-radius: var(--radius-lg);
  padding: 1.5rem;
  box-shadow: var(--shadow-md);
  margin: 1.5rem 0;
  border: 1px solid var(--chart-border);
}

/* çµ±è¨ˆè¡¨ç¤º */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.stat-item {
  text-align: center;
  padding: 1.5rem;
  background: var(--card-background);
  border-radius: var(--radius-md);
  border: 1px solid var(--border-color);
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.stat-item::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
}

.stat-item:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.stat-value {
  font-size: 1.75rem;
  font-weight: 800;
  color: var(--primary-color);
  margin-bottom: 0.5rem;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.stat-label {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ */
@media (max-width: 768px) {
  .container {
    padding: 0 0.5rem;
  }
  
  .app-header {
    padding: 1.5rem 0.5rem;
  }
  
  .app-header h1 {
    font-size: 1.5rem;
  }
  
  .card {
    padding: 1rem;
    margin-bottom: 1rem;
  }
  
  .btn-group {
    flex-direction: column;
  }
  
  .btn-group .btn {
    width: 100%;
  }
  
  .grid-cols-2,
  .grid-cols-3 {
    grid-template-columns: 1fr;
  }
  
  .stats-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 480px) {
  .log-item {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
  
  .log-actions {
    width: 100%;
    justify-content: space-between;
  }
}

/* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

.fade-in {
  animation: fadeIn 0.4s ease-out;
}

.slide-in {
  animation: slideIn 0.3s ease-out;
}

/* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--background-color);
}

::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¡¨ç¤ºã®æ”¹å–„ */
*:focus-visible {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ */
#darkModeToggle {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.3);
  color: white;
  backdrop-filter: blur(10px);
  transition: all 0.2s ease;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  margin-bottom: 20px;
}

#darkModeToggle:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒœã‚¿ãƒ³ */
.dark-mode #darkModeToggle {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.2);
}

.dark-mode #darkModeToggle:hover {
  background: rgba(255, 255, 255, 0.2);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ */
@media (prefers-color-scheme: dark) {
  :root {
    --background-color: #0f172a;
    --card-background: #1e293b;
    --text-primary: #f1f5f9;
    --text-secondary: #cbd5e1;
    --text-muted: #64748b;
    --border-color: #334155;
  }
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ç”¨ã®äºˆæ¸¬ãƒ»ãƒãƒ£ãƒ¼ãƒˆè‰² */
.dark-mode {
  /* ãƒšãƒ¼ã‚¸å…¨ä½“ã®è‰² - ã‚ˆã‚Šé«˜ã„å„ªå…ˆåº¦ã§é©ç”¨ */
  --background-color: #0f172a !important;
  --card-background: #1e293b !important;
  --text-primary: #f1f5f9 !important;
  --text-secondary: #cbd5e1 !important;
  --text-muted: #64748b !important;
  --border-color: #334155 !important;
  
  /* äºˆæ¸¬ãƒ»ãƒãƒ£ãƒ¼ãƒˆç”¨ã®è‰² */
  --prediction-bg: #0c4a6e !important;
  --prediction-border: #38bdf8 !important;
  --prediction-text: #e0f2fe !important;
  --prediction-text-secondary: #bae6fd !important;
  --chart-awake: #fca5a5 !important;
  --chart-sleep: #93c5fd !important;
  --chart-bg: #1e293b !important;
  --chart-border: #334155 !important;
  
  /* ãƒ˜ãƒƒãƒ€ãƒ¼ã®èƒŒæ™¯è‰²ã‚’èª¿æ•´ */
  --header-bg-start: #1e40af !important;
  --header-bg-end: #059669 !important;
  
  /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã®èƒŒæ™¯è‰²ã‚’èª¿æ•´ */
  --status-success-bg: rgba(16, 185, 129, 0.2) !important;
  --status-info-bg: rgba(99, 102, 241, 0.2) !important;
  --status-warning-bg: rgba(245, 158, 11, 0.2) !important;
  
  /* ãƒœã‚¿ãƒ³ã®è‰²ã‚’èª¿æ•´ */
  --btn-outline-color: #60a5fa !important;
  --btn-outline-border: #60a5fa !important;
  --btn-outline-hover-bg: #60a5fa !important;
  --btn-outline-hover-color: #1e293b !important;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒ˜ãƒƒãƒ€ãƒ¼èƒŒæ™¯ */
.dark-mode .app-header {
  background: linear-gradient(135deg, var(--header-bg-start), var(--header-bg-end));
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
.dark-mode .status-success {
  background: var(--status-success-bg);
}

.dark-mode .status-info {
  background: var(--status-info-bg);
}

.dark-mode .status-warning {
  background: var(--status-warning-bg);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒœã‚¿ãƒ³ */
.dark-mode .btn-outline {
  color: var(--btn-outline-color);
  border-color: var(--btn-outline-border);
}

.dark-mode .btn-outline:hover {
  background: var(--btn-outline-hover-bg);
  color: var(--btn-outline-hover-color);
}

/* detailsè¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚° */
details summary {
  cursor: pointer;
  padding: 0.5rem;
  background: var(--background-color);
  border-radius: var(--radius-md);
  color: var(--text-secondary);
  transition: all 0.2s ease;
}

details summary:hover {
  background: var(--border-color);
}

details > div {
  background: var(--background-color);
  margin-top: 0.5rem;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®detailsè¦ç´  */
.dark-mode details summary {
  background: var(--card-background);
  color: var(--text-secondary);
}

.dark-mode details summary:hover {
  background: var(--border-color);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®detailså†…å®¹ */
.dark-mode details > div {
  background: var(--card-background);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®çµ±è¨ˆè¡¨ç¤º */
.dark-mode .stat-item {
  background: var(--card-background);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®çµ±è¨ˆå€¤ã®è‰² */
.dark-mode .stat-value {
  color: var(--primary-color);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®çµ±è¨ˆãƒ©ãƒ™ãƒ«ã®è‰² */
.dark-mode .stat-label {
  color: var(--text-secondary);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®äºˆæ¸¬ã‚«ãƒ¼ãƒ‰ã®æ”¹å–„ */
.dark-mode .prediction-card {
  box-shadow: 0 4px 6px -1px rgba(56, 189, 248, 0.2), 0 2px 4px -2px rgba(56, 189, 248, 0.2);
}

.dark-mode .prediction-card::before {
  background: linear-gradient(90deg, var(--prediction-border), #60a5fa);
}

.dark-mode .prediction-item:hover {
  background: rgba(56, 189, 248, 0.1);
}

.dark-mode .prediction-item:not(:last-child)::after {
  background: linear-gradient(to bottom, transparent, var(--prediction-border), transparent);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®äºˆæ¸¬çµ±è¨ˆã®èƒŒæ™¯ */
.dark-mode .card .card {
  background: var(--card-background);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®äºˆæ¸¬çµ±è¨ˆã®ãƒœãƒ¼ãƒ€ãƒ¼ */
.dark-mode .card .card {
  border-color: var(--border-color);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®å‹•çš„ç”Ÿæˆè¦ç´  */
.dark-mode .log-item .log-time {
  color: var(--text-primary);
}

.dark-mode .log-item .log-type {
  color: var(--text-secondary);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®äºˆæ¸¬çµ±è¨ˆã®èª¬æ˜æ–‡èƒŒæ™¯ */
.dark-mode .prediction-stats-info {
  background: var(--card-background) !important;
  color: var(--text-secondary) !important;
  border-color: var(--border-color) !important;
}

/* æœˆé½¢æƒ…å ±è¡¨ç¤º */
.months-info {
  text-align: center;
  margin-top: 1rem;
  padding: 0.75rem;
  background: rgba(99, 102, 241, 0.15);
  border-radius: var(--radius-md);
  color: var(--primary-color);
  font-size: 0.9rem;
  font-weight: 600;
  border: 1px solid rgba(99, 102, 241, 0.2);
}

/* äºˆæ¸¬çµ±è¨ˆã®èª¬æ˜æ–‡èƒŒæ™¯ */
.prediction-stats-info {
  margin-top: 1rem;
  padding: 1rem;
  background: rgba(16, 185, 129, 0.15);
  border-radius: var(--radius-md);
  border-left: 4px solid var(--secondary-color);
  color: var(--secondary-color);
  font-weight: 600;
}

/* ç¡çœ ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‚¾å‘è¡¨ç¤º */
.pattern-trend-info {
  margin-top: 1rem;
  padding: 1rem;
  background: var(--background-color);
  border-radius: var(--radius-md);
  border-left: 4px solid var(--accent-color);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®æœˆé½¢æƒ…å ±è¡¨ç¤º */
.dark-mode .months-info {
  background: rgba(99, 102, 241, 0.2) !important;
  border-color: rgba(99, 102, 241, 0.4) !important;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®äºˆæ¸¬çµ±è¨ˆã®èª¬æ˜æ–‡èƒŒæ™¯ */
.dark-mode .prediction-stats-info {
  background: rgba(16, 185, 129, 0.2) !important;
  border-color: var(--secondary-color) !important;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®äºˆæ¸¬çµ±è¨ˆã®å‚¾å‘è¡¨ç¤º */
.dark-mode .pattern-trend-info {
  background: var(--card-background) !important;
  border-color: var(--accent-color) !important;
}
</style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js?v=20250810-1"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.umd.min.js?v=20250810-1"></script>
</head>
<body>

<div class="app-header">
  <h1>ğŸŒ™ ãƒ™ãƒ“ãƒ¼ã‚¹ãƒªãƒ¼ãƒ—äºˆæ¸¬</h1>
  <div class="subtitle">èµ¤ã¡ã‚ƒã‚“ã®ç¡çœ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨˜éŒ²ãƒ»äºˆæ¸¬</div>
</div>
  
<div class="container">
  <!-- ã‚¯ã‚¤ãƒƒã‚¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ -->
  <div class="card">
    <div class="card-header">
      <span class="icon">âš¡</span>
      <h3>ã‚¯ã‚¤ãƒƒã‚¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</h3>
    </div>
    <div class="btn-group">
      <button class="btn btn-primary" onclick="addLog('wake')">
        <span>ğŸŒ…</span>
        èµ·ããŸ
      </button>
      <button class="btn btn-secondary" onclick="addLog('nap')">
        <span>ğŸ˜´</span>
        å¯ãŸ
      </button>
    </div>
  </div>

    <!-- äºˆæ¸¬è¡¨ç¤º -->
    <div class="card prediction-card">
      <div class="card-header">
        <span class="icon">ğŸ”®</span>
        <h3>æ¬¡ã®å¯ã‹ã—ã¤ã‘äºˆæ¸¬</h3>
      </div>
  <div id="prediction"></div>
    </div>
  
  
  <!-- æ™‚é–“æŒ‡å®šã§è¿½åŠ ãƒ»ç·¨é›† -->
  <div class="card">
    <div class="card-header">
      <span class="icon">â°</span>
      <h3>æ™‚é–“æŒ‡å®šã§è¿½åŠ ãƒ»ç·¨é›†</h3>
    </div>
    <div class="grid grid-cols-3">
      <div class="form-group">
        <label class="form-label">ã‚¿ã‚¤ãƒ—</label>
        <select id="typeSelect" class="form-control">
      <option value="wake">èµ·ããŸ</option>
      <option value="nap">å¯ãŸ</option>
    </select>
      </div>
      <div class="form-group">
        <label class="form-label">æ™‚åˆ»</label>
        <input id="timeInput" type="time" step="60" class="form-control">
      </div>
      <div class="form-group">
        <div class="btn-group">
          <button id="addBtn" class="btn btn-primary" onclick="handleAddOrUpdate()">è¿½åŠ </button>
          <button id="cancelEditBtn" class="btn btn-outline" onclick="cancelEdit()" style="display:none;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
      </div>
    </div>
    <div id="editStatus" class="status status-info" style="display:none;"></div>
  </div>

  <!-- è¨˜éŒ²è¡¨ç¤º -->
  <div class="card">
    <div class="card-header">
      <span class="icon">ğŸ“</span>
      <h3>è¨˜éŒ²</h3>
    </div>
<div id="log"></div>
  </div>

  
  <!-- è¡¨ç¤ºæ—¥è¨­å®š -->
  <div class="card">
    <div class="card-header">
      <span class="icon">ğŸ“…</span>
      <h3>è¡¨ç¤ºæ—¥</h3>
    </div>
    <div class="grid grid-cols-4">
      <div class="form-group">
        <input id="viewDate" type="date" class="form-control">
      </div>
      <div class="form-group">
        <button class="btn btn-accent" onclick="goToday()">ä»Šæ—¥</button>
        <button class="btn btn-outline" onclick="shiftDay(-1)">å‰æ—¥</button>
        <button class="btn btn-outline" onclick="shiftDay(1)">ç¿Œæ—¥</button>
      </div>
    </div>
    <div id="viewDateStatus" class="status status-info"></div>
  </div>

  <!-- ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒãƒ£ãƒ¼ãƒˆ -->
  <div class="chart-container">
    <div class="card-header">
      <span class="icon">ğŸ“Š</span>
      <h3>ç¡çœ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³</h3>
    </div>
<canvas id="timelineChart" height="150"></canvas>
  </div>

    <!-- ç”Ÿå¹´æœˆæ—¥è¨­å®š -->
    <div class="card">
      <div class="card-header">
        <span class="icon">ğŸ‚</span>
        <h3>ç”Ÿå¹´æœˆæ—¥</h3>
      </div>
      <div class="grid grid-cols-2">
        <div class="form-group">
          <input id="birthInput" type="date" class="form-control">
        </div>
        <div class="form-group">
          <button class="btn btn-secondary" onclick="saveBirth()">ä¿å­˜</button>
        </div>
      </div>
      <br>
      <div id="birthStatus" class="status status-info"></div>
    </div>
  

  <!-- ã´ã‚ˆãƒ­ã‚°ã‚¤ãƒ³ãƒãƒ¼ãƒˆ -->
  <div class="card">
    <div class="card-header">
      <span class="icon">ğŸ“</span>
      <h3>ã´ã‚ˆãƒ­ã‚°ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</h3>
    </div>
    <div class="grid grid-cols-2">
      <div class="form-group">
        <input id="piyoFile" type="file" accept=".txt" class="form-control">
      </div>
      <div class="form-group">
        <button class="btn btn-secondary" onclick="handleImportPiyolog()">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
      </div>
    </div>
    <div id="importStatus" class="status status-info"></div>
    <div style="color:var(--text-muted); font-size:0.9em; margin-top:0.5rem;">
    ãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã‚‹å…¨ã¦ã®æ—¥ã®ã€Œèµ·ãã‚‹ï¼å¯ã‚‹ã€ã‚’å–ã‚Šè¾¼ã¿ã¾ã™ï¼ˆåŒæ—¥ã®æ—¢å­˜è¨˜éŒ²ã¯ä¸Šæ›¸ãï¼‰ã€‚
  </div>
</div>

  <!-- CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ -->
  <div class="card">
    <div class="card-header">
      <span class="icon">ğŸ’¾</span>
      <h3>CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</h3>
    </div>
    <button class="btn btn-primary" onclick="exportSleepData()">
      <span>ğŸ“Š</span>
      ç¡çœ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    </button>
    <div id="analysisStatus" class="status status-info" style="margin-top:0.5rem;"></div>
  </div>

  <button id="darkModeToggle" class="btn btn-outline" style="background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.3); color: white; backdrop-filter: blur(10px); z-index: 1000;">
    ğŸŒ™
  </button>
</div>

<script>
// ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ—¥ä»˜ã”ã¨ã®è¾æ›¸ã«ç§»è¡Œï¼ˆäº’æ›: æ—§é…åˆ—â†’ä»Šæ—¥ã®æ—¥ä»˜ã«ç§»è¡Œï¼‰
let allLogsRaw = null;
try {
  allLogsRaw = JSON.parse(localStorage.getItem('babyLogs') || 'null');
} catch (_) {
  allLogsRaw = null;
}

function __computeTodayKey() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}/${m}/${day}`;
}

let allLogs = {};
if (Array.isArray(allLogsRaw)) {
  // æ—§å½¢å¼ï¼ˆé…åˆ—ï¼‰â†’ ä»Šæ—¥ã®æ—¥ä»˜ã«ç§»ã—æ›¿ãˆ
  const todayKey = __computeTodayKey();
  allLogs[todayKey] = allLogsRaw.filter(l => l && (l.type === 'wake' || l.type === 'nap'));
} else if (allLogsRaw && typeof allLogsRaw === 'object') {
  allLogs = allLogsRaw;
  // å„æ—¥ã”ã¨ã«å‹ãƒ•ã‚£ãƒ«ã‚¿ã‚’é©ç”¨
  for (const k of Object.keys(allLogs)) {
    const arr = Array.isArray(allLogs[k]) ? allLogs[k] : [];
    allLogs[k] = arr.filter(l => l && (l.type === 'wake' || l.type === 'nap'));
  }
} else {
  const todayKey = __computeTodayKey();
  allLogs[todayKey] = [];
}
localStorage.setItem('babyLogs', JSON.stringify(allLogs));

let currentDateKey = __computeTodayKey();
let logs = allLogs[currentDateKey] || [];
let timelineChart = null;
let editingIndex = null;
const BIRTH_KEY = "babyBirthDate"; // YYYY-MM-DD ã§ä¿å­˜

function nowTimeString() {
  const now = new Date();
  const hh = String(now.getHours()).padStart(2, '0');
  const mm = String(now.getMinutes()).padStart(2, '0');
  return `${hh}:${mm}`;
}

function getSortKey(timeStr) {
  const [h, m] = timeStr.split(":").map(Number);
  // 07:00ã‚’æ—¥å¢ƒç•Œã«ã—ã€<07:00 ã¯ç¿Œæ—¥æ‰±ã„
  const minutes = h * 60 + m;
  return minutes < 7 * 60 ? minutes + 24 * 60 : minutes;
}

function sortLogs() {
  logs.sort((a, b) => getSortKey(a.time) - getSortKey(b.time));
}

function saveAllLogs() {
  localStorage.setItem('babyLogs', JSON.stringify(allLogs));
}

function setCurrentDateKey(newKey) {
  currentDateKey = newKey;
  if (!allLogs[currentDateKey]) allLogs[currentDateKey] = [];
  // å‹ãƒ•ã‚£ãƒ«ã‚¿
  allLogs[currentDateKey] = allLogs[currentDateKey].filter(l => l && (l.type === 'wake' || l.type === 'nap'));
  logs = allLogs[currentDateKey];
  sortLogs();
  saveAllLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  updateViewDateStatus();
  // äºˆæ¸¬ç²¾åº¦çµ±è¨ˆã‚’æ›´æ–°
  showPredictionStats();
}

function keyFromInputValue(value) { // YYYY-MM-DD -> YYYY/MM/DD
  if (!value) return null;
  const [y, m, d] = value.split('-');
  return `${y}/${m}/${d}`;
}

function inputValueFromKey(key) { // YYYY/MM/DD -> YYYY-MM-DD
  if (!key) return '';
  const [y, m, d] = key.split('/');
  return `${y}-${m}-${d}`;
}

function goToday() {
  setCurrentDateKey(__computeTodayKey());
  const viewDateEl = document.getElementById('viewDate');
  if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);
}

function shiftDay(delta) {
  const [y, m, d] = currentDateKey.split('/').map(Number);
  const dt = new Date(y, m - 1, d);
  dt.setDate(dt.getDate() + delta);
  const key = `${dt.getFullYear()}/${String(dt.getMonth() + 1).padStart(2, '0')}/${String(dt.getDate()).padStart(2, '0')}`;
  setCurrentDateKey(key);
  const viewDateEl = document.getElementById('viewDate');
  if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);
}

function updateViewDateStatus() {
  const status = document.getElementById('viewDateStatus');
  if (!status) return;
  status.textContent = `è¡¨ç¤ºä¸­: ${currentDateKey}ï¼ˆ${logs.length}ä»¶ï¼‰`;
}

function addLog(type) {
  const time = nowTimeString();
  addLogAt(type, time);
}

function addLogAt(type, time) {
  if (!time || !/^\d{2}:\d{2}$/.test(time)) {
    alert('æ™‚åˆ»ã¯ HH:MM å½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„');
    return;
  }
  if (!(type === 'wake' || type === 'nap')) {
    alert('è¿½åŠ ã§ãã‚‹ã®ã¯ã€Œèµ·ããŸã€ã€Œå¯ãŸã€ã®ã¿ã§ã™');
    return;
  }
  logs.push({ type, time });
  sortLogs();
  allLogs[currentDateKey] = logs;
  saveAllLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  // äºˆæ¸¬ç²¾åº¦çµ±è¨ˆã‚’æ›´æ–°
  showPredictionStats();
}

function startEditLog(index) {
  const target = logs[index];
  if (!target) return;
  editingIndex = index;
  document.getElementById('typeSelect').value = target.type;
  document.getElementById('timeInput').value = target.time;
  const addBtn = document.getElementById('addBtn');
  addBtn.textContent = 'æ›´æ–°';
  document.getElementById('cancelEditBtn').style.display = '';
  document.getElementById('editStatus').textContent = `ç·¨é›†ä¸­: ${target.time} - ${translateType(target.type)}`;
}

function handleAddOrUpdate() {
  const type = document.getElementById('typeSelect').value;
  const time = document.getElementById('timeInput').value;
  if (!time || !/^\d{2}:\d{2}$/.test(time)) {
    alert('æ™‚åˆ»ã¯ HH:MM å½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„');
    return;
  }
  if (editingIndex === null) {
    addLogAt(type, time);
  } else {
    logs[editingIndex] = { type, time };
    sortLogs();
    allLogs[currentDateKey] = logs;
    saveAllLogs();
    renderLogs();
    updateTimelineChart();
    updatePrediction();
    // äºˆæ¸¬ç²¾åº¦çµ±è¨ˆã‚’æ›´æ–°
    showPredictionStats();
    cancelEdit();
  }
}

function cancelEdit() {
  editingIndex = null;
  const addBtn = document.getElementById('addBtn');
  addBtn.textContent = 'ã“ã®æ™‚é–“ã§è¿½åŠ ';
  document.getElementById('cancelEditBtn').style.display = 'none';
  document.getElementById('editStatus').textContent = '';
  const timeInputEl = document.getElementById('timeInput');
  if (timeInputEl) timeInputEl.value = nowTimeString();
}

function deleteLog(index) {
  const target = logs[index];
  if (!target) return;
  const ok = confirm(`å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n${target.time} - ${translateType(target.type)}`);
  if (!ok) return;
  logs.splice(index, 1);
  allLogs[currentDateKey] = logs;
  saveAllLogs();
  sortLogs();
  renderLogs();
  updateTimelineChart();
  updatePrediction();
  // äºˆæ¸¬ç²¾åº¦çµ±è¨ˆã‚’æ›´æ–°
  showPredictionStats();
  cancelEdit();
}

function renderLogs() {
  const container = document.getElementById("log");
  const total = logs.length;
  const recentCount = 3;
  
  if (total === 0) {
    container.innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ“</div>
        <div>ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">ã€Œèµ·ããŸã€ã¾ãŸã¯ã€Œå¯ãŸã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦è¨˜éŒ²ã‚’é–‹å§‹ã—ã¦ãã ã•ã„</div>
      </div>
    `;
    return;
  }

  if (total <= recentCount) {
    const allHtml = logs.map((l, i) => {
      return createLogItemHtml(l, i);
    }).join('');
    container.innerHTML = allHtml;
    return;
  }

  const olderCount = total - recentCount;
  const recentBaseIndex = total - recentCount;

  const olderHtml = logs.slice(0, olderCount).map((l, i) => {
    const idx = i;
    return createLogItemHtml(l, idx);
  }).join('');

  const recentHtml = logs.slice(recentBaseIndex).map((l, i) => {
    const idx = recentBaseIndex + i;
    return createLogItemHtml(l, idx);
  }).join('');

  const detailsHtml = `
    <details style="margin-bottom: 1rem;">
      <summary style="cursor: pointer; padding: 0.5rem; border-radius: var(--radius-md);">
        ğŸ“š éå»ã®è¨˜éŒ²ã‚’è¡¨ç¤ºï¼ˆ${olderCount}ä»¶ï¼‰
      </summary>
      <div style="margin-top: 0.5rem;">
        ${olderHtml || '<div style="text-align: center; color: var(--text-muted); padding: 1rem;">è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</div>'}
      </div>
    </details>
  `;

  container.innerHTML = detailsHtml + recentHtml;
}

function createLogItemHtml(log, index) {
  const typeClass = log.type === 'wake' ? 'wake' : 'nap';
  const typeIcon = log.type === 'wake' ? 'ğŸŒ…' : 'ğŸ˜´';
  const typeText = translateType(log.type);
  
  return `
    <div class="log-item ${typeClass} slide-in">
      <div>
        <div class="log-time">${log.time}</div>
        <div class="log-type">${typeIcon} ${typeText}</div>
      </div>
      <div class="log-actions">
        <button class="btn btn-sm btn-outline" onclick="startEditLog(${index})">
          âœï¸ ç·¨é›†
        </button>
        <button class="btn btn-sm btn-danger" onclick="deleteLog(${index})">
          ğŸ—‘ï¸ å‰Šé™¤
        </button>
      </div>
    </div>
  `;
}

function translateType(type) {
  return type === "wake" ? "èµ·ããŸ" :
         type === "nap" ? "å¯ãŸ" : type;
}

// ç”Ÿå¹´æœˆæ—¥ã®ä¿å­˜ãƒ»èª­è¾¼ã¨æœˆé½¢ãƒ™ãƒ¼ã‚¹ã®æ¨å®š
function saveBirth(showSavedMessage = true) {
  const input = document.getElementById('birthInput');
  const status = document.getElementById('birthStatus');
  if (!input || !status) return;
  const value = input.value; // YYYY-MM-DD or ''
  if (!value) {
    localStorage.removeItem(BIRTH_KEY);
    status.textContent = 'æœªè¨­å®š';
    updatePrediction();
    return;
  }
  // ç°¡æ˜“ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) {
    status.textContent = 'æ—¥ä»˜å½¢å¼ãŒä¸æ­£ã§ã™ (YYYY-MM-DD)';
    return;
  }
  localStorage.setItem(BIRTH_KEY, value);
  const birth = loadBirth();
  const months = birth ? calculateMonthsAge(birth) : null;
  status.textContent = months !== null ? `ä¿å­˜ã—ã¾ã—ãŸï¼ˆæœˆé½¢: ${months}ãƒ¶æœˆï¼‰` : 'ä¿å­˜ã—ã¾ã—ãŸ';
  if (!showSavedMessage) {
    // å³æ™‚ä¿å­˜æ™‚ã¯æ§ãˆã‚ãªè¡¨ç¤º
    status.textContent = months !== null ? `ä¿å­˜æ¸ˆã¿ï¼ˆæœˆé½¢: ${months}ãƒ¶æœˆï¼‰` : 'ä¿å­˜æ¸ˆã¿';
  }
  updatePrediction();
}

function loadBirth() {
  const stored = localStorage.getItem(BIRTH_KEY);
  if (!stored) return null;
  // Local 00:00 ã«è¨­å®š
  const [y, m, d] = stored.split('-').map(Number);
  const dt = new Date();
  dt.setHours(0, 0, 0, 0);
  dt.setFullYear(y, m - 1, d);
  return isNaN(dt.getTime()) ? null : dt;
}

function calculateMonthsAge(birthDate, refDate = new Date()) {
  if (!birthDate) return null;
  const y1 = birthDate.getFullYear();
  const m1 = birthDate.getMonth();
  const d1 = birthDate.getDate();
  const y2 = refDate.getFullYear();
  const m2 = refDate.getMonth();
  const d2 = refDate.getDate();
  let months = (y2 - y1) * 12 + (m2 - m1);
  if (d2 < d1) months -= 1; // å½“æœˆã®èª•ç”Ÿæ—¥æœªåˆ°é”ãªã‚‰-1
  return Math.max(0, months);
}

function getAwakeWindowByMonths(monthsAge) {
  // å‚è€ƒãƒ¬ãƒ³ã‚¸ï¼ˆåˆ†ï¼‰: æ–‡çŒ®ã‚„ä¸€èˆ¬çš„ãªç›®å®‰ã«åŸºã¥ãç·©ã‚ã®ç¯„å›²
  if (monthsAge === null) return [120, 150];
  if (monthsAge <= 2) return [45, 90];
  if (monthsAge <= 4) return [75, 120];
  if (monthsAge <= 6) return [90, 150];
  if (monthsAge <= 8) return [120, 180];
  if (monthsAge <= 10) return [150, 210];
  if (monthsAge <= 12) return [180, 240];
  return [210, 300];
}

function getNapLengthByMonths(monthsAge, nextNapStart) {
  const hour = nextNapStart.getHours();
  // åŸºæœ¬ãƒ¬ãƒ³ã‚¸ï¼ˆåˆ†ï¼‰
  let minMax;
  if (monthsAge === null) {
    minMax = [60, 90];
  } else if (monthsAge <= 2) {
    minMax = [60, 120];
  } else if (monthsAge <= 4) {
    minMax = [60, 120];
  } else if (monthsAge <= 6) {
    minMax = [60, 90];
  } else if (monthsAge <= 8) {
    minMax = [45, 90];
  } else if (monthsAge <= 12) {
    minMax = [45, 90];
  } else {
    minMax = [45, 60];
  }
  let nap = randomIntInclusive(minMax[0], minMax[1]);
  // 15æ™‚ä»¥é™ã¯çŸ­ã‚ã«åˆ¶é™
  if (hour >= 15) {
    nap = Math.min(nap, 45);
  }
  return nap;
}

function randomIntInclusive(min, max) {
  const mn = Math.ceil(min);
  const mx = Math.floor(max);
  return Math.floor(Math.random() * (mx - mn + 1)) + mn;
}

function updatePrediction() {
  if (logs.length === 0) {
    document.getElementById("prediction").innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ”®</div>
        <div>ã“ã®æ—¥ã®èµ·åºŠãƒ­ã‚°å¾Œã«äºˆæ¸¬ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">ã€Œèµ·ããŸã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦è¨˜éŒ²ã‚’é–‹å§‹ã—ã¦ãã ã•ã„</div>
      </div>
    `;
    return;
  }
  // ç›´è¿‘ã®ã€ŒçŠ¶æ…‹ã€ãƒ­ã‚°ï¼ˆwake/napï¼‰ã®ã¿ã‚’è¦‹ã‚‹ã€‚
  const lastStateIndex = [...logs].map((l, i) => ({...l, i}))
    .filter(l => l.type === 'wake' || l.type === 'nap')
    .map(l => l.i)
    .pop();
  if (lastStateIndex === undefined) {
    document.getElementById("prediction").innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ”®</div>
        <div>ã“ã®æ—¥ã®èµ·åºŠãƒ­ã‚°å¾Œã«äºˆæ¸¬ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">ã€Œèµ·ããŸã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦è¨˜éŒ²ã‚’é–‹å§‹ã—ã¦ãã ã•ã„</div>
      </div>
    `;
    return;
  }
  const lastState = logs[lastStateIndex];
  if (lastState.type !== 'wake') {
    document.getElementById("prediction").innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ”®</div>
        <div>ã“ã®æ—¥ã®èµ·åºŠãƒ­ã‚°å¾Œã«äºˆæ¸¬ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">ç¾åœ¨ã¯ç¡çœ ä¸­ã®ã‚ˆã†ã§ã™</div>
      </div>
    `;
    return;
  }

  const [h, m] = lastState.time.split(":").map(Number);
  const wakeTime = new Date();
  wakeTime.setHours(h, m);

  const birthDate = loadBirth();
  const monthsAge = birthDate ? calculateMonthsAge(birthDate, new Date()) : null;

  // éå»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®äºˆæ¸¬ã‚’å–å¾—
  const historicalPrediction = getHistoricalPrediction(wakeTime, monthsAge);
  
  // æœˆé½¢ãƒ™ãƒ¼ã‚¹ã®åŸºæœ¬äºˆæ¸¬
  const [awakeMin, awakeMax] = getAwakeWindowByMonths(monthsAge);
  const basicAwakeMinutes = randomIntInclusive(awakeMin, awakeMax);
  const basicNextNapStart = new Date(wakeTime.getTime() + basicAwakeMinutes * 60000);
  const basicNapLengthMinutes = getNapLengthByMonths(monthsAge, basicNextNapStart);

  // éå»ãƒ‡ãƒ¼ã‚¿ã¨åŸºæœ¬äºˆæ¸¬ã‚’çµ„ã¿åˆã‚ã›ãŸæœ€çµ‚äºˆæ¸¬
  let finalAwakeMinutes, finalNapLengthMinutes;
  if (historicalPrediction) {
    // éå»ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã€åŸºæœ¬äºˆæ¸¬ã¨éå»ãƒ‡ãƒ¼ã‚¿ã‚’é‡ã¿ä»˜ã‘ã§çµ„ã¿åˆã‚ã›
    const historicalWeight = 0.7; // éå»ãƒ‡ãƒ¼ã‚¿ã®é‡ã¿
    const basicWeight = 0.3; // åŸºæœ¬äºˆæ¸¬ã®é‡ã¿
    
    finalAwakeMinutes = Math.round(
      historicalPrediction.avgAwakeTime * historicalWeight + 
      basicAwakeMinutes * basicWeight
    );
    finalNapLengthMinutes = Math.round(
      historicalPrediction.avgNapLength * historicalWeight + 
      basicNapLengthMinutes * basicWeight
    );
  } else {
    // éå»ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯åŸºæœ¬äºˆæ¸¬ã‚’ä½¿ç”¨
    finalAwakeMinutes = basicAwakeMinutes;
    finalNapLengthMinutes = basicNapLengthMinutes;
  }

  const nextNapStart = new Date(wakeTime.getTime() + finalAwakeMinutes * 60000);
  const wakeUpTime = new Date(nextNapStart.getTime() + finalNapLengthMinutes * 60000);

  const monthsInfo = monthsAge !== null ? `æœˆé½¢: ${monthsAge}ãƒ¶æœˆ` : "";
  const historicalInfo = historicalPrediction ? 
    `<small style="color:#666;">éå»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: è¦šé†’æ™‚é–“ ${Math.round(historicalPrediction.avgAwakeTime)}åˆ†ã€ç¡çœ æ™‚é–“ ${Math.round(historicalPrediction.avgNapLength)}åˆ†</small>` : "";

  document.getElementById("prediction").innerHTML = `
    <div class="grid grid-cols-3">
      <div class="prediction-item">
        <div class="prediction-label">å¯ã‹ã—ã¤ã‘ç›®å®‰</div>
        <div class="prediction-time">${formatTime(nextNapStart)}</div>
        <div style="font-size: 0.8rem; color: var(--text-muted);">ã”ã‚ãƒ™ãƒƒãƒ‰ã«</div>
      </div>
      <div class="prediction-item">
        <div class="prediction-label">å…¥çœ äºˆæ¸¬</div>
        <div class="prediction-time">${formatTime(new Date(nextNapStart.getTime() + 5*60000))}</div>
        <div style="font-size: 0.8rem; color: var(--text-muted);">ç´„5åˆ†å¾Œ</div>
      </div>
      <div class="prediction-item">
        <div class="prediction-label">èµ·åºŠäºˆæ¸¬</div>
        <div class="prediction-time">${formatTime(wakeUpTime)}</div>
        <div style="font-size: 0.8rem; color: var(--text-muted);">ç¡çœ æ™‚é–“ ${Math.round(finalNapLengthMinutes)}åˆ†</div>
      </div>
    </div>
    ${monthsInfo ? `<div class="months-info">${monthsInfo}</div>` : ''}
    ${historicalInfo ? `<div class="prediction-stats-info">${historicalInfo}</div>` : ''}
  `;
}

function formatTime(date) {
  return date.toTimeString().slice(0,5);
}

function updateTimelineChart() {
  const isDateAdapterReady = () => {
    const a = Chart && Chart._adapters && Chart._adapters._date;
    return !!(a && a.format && a.parse && a.add && a.diff && a.startOf && a.endOf && a.formats);
  };
  // è¡¨ç¤ºæ—¥ã® 07:00 ã‚’è»¸
  const [y, m, d] = currentDateKey.split('/').map(Number);
  const baseStart = new Date(y, m - 1, d, 7, 0, 0, 0);
  const baseStartMs = baseStart.getTime();
  const rangeDays = 7; // å¸¸ã«1é€±é–“è¡¨ç¤º

  // é€±è¡¨ç¤º: å„æ—¥ã‚’ç¸¦ã«ä¸¦ã¹ã€Xè»¸ã¯24æ™‚é–“ï¼ˆ7:00â†’ç¿Œ7:00ï¼‰ã§æƒãˆã‚‹
  const dayLabels = [];
  const awakeData = [];
  const sleepData = [];

  const labelForDate = (dt) => {
    const w = ['æ—¥','æœˆ','ç«','æ°´','æœ¨','é‡‘','åœŸ'];
    return `${String(dt.getMonth()+1).padStart(2,'0')}/${String(dt.getDate()).padStart(2,'0')}(${w[dt.getDay()]})`;
  };

  const generateDayEvents = (dt) => {
    const dayStart = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), 7, 0, 0, 0);
    const dayStartMs = dayStart.getTime();
    const dayEndMs = dayStartMs + 24 * 3600000;

    // å‰æ—¥/å½“æ—¥/ç¿Œæ—¥ã®ãƒ­ã‚°ã‹ã‚‰ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ä½œæˆ
    const seq = [];
    for (const off of [-1, 0, 1]) {
      const t = new Date(dt);
      t.setDate(t.getDate() + off);
      const key = `${t.getFullYear()}/${String(t.getMonth()+1).padStart(2,'0')}/${String(t.getDate()).padStart(2,'0')}`;
      const arr = (allLogs[key] || []).filter(l => l.type === 'wake' || l.type === 'nap')
        .sort((a,b)=>getSortKey(a.time)-getSortKey(b.time));
      for (const l of arr) {
        const [hh, mm] = l.time.split(':').map(Number);
        const base = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 7, 0, 0, 0);
        const abs = new Date(base);
        if (hh < 7) abs.setDate(abs.getDate() + 1);
        abs.setHours(hh, mm, 0, 0);
        seq.push({ type: l.type, date: abs });
      }
    }
    seq.sort((a,b)=>a.date.getTime()-b.date.getTime());

    // é€£ç¶šãƒšã‚¢ã‹ã‚‰å½“æ—¥ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«ã‚¯ãƒªãƒƒãƒ—ã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆåŒ–
    const evs = [];
    for (let i = 0; i < seq.length - 1; i++) {
      let start = seq[i].date.getTime();
      let end = seq[i+1].date.getTime();
      if (end <= dayStartMs || start >= dayEndMs) continue;
      if (start < dayStartMs) start = dayStartMs;
      if (end > dayEndMs) end = dayEndMs;
      const label = seq[i].type === 'nap' ? 'ç¡çœ ' : 'è¦šé†’';
      const color = seq[i].type === 'nap' ? getComputedStyle(document.documentElement).getPropertyValue('--chart-sleep').trim() : getComputedStyle(document.documentElement).getPropertyValue('--chart-awake').trim();
      evs.push({ label, start: new Date(start), end: new Date(end), color, dayStartMs });
    }
    return { evs, dayStartMs };
  };

  for (let i = 0; i < rangeDays; i++) {
    const dt = new Date(y, m - 1, d);
    dt.setDate(dt.getDate() + i);
    const dayLabel = rangeDays === 1 ? 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«' : labelForDate(dt);
    if (rangeDays > 1) dayLabels.push(dayLabel);

    const { evs, dayStartMs } = generateDayEvents(dt);
    for (const ev of evs) {
      // é€±è¡¨ç¤ºã§ã¯å…¨æ—¥ã®Xè»¸ã‚’åŒã˜24hã«æƒãˆã‚‹ãŸã‚ã€åŸºæº–æ—¥ã® 7:00 ã‚’0ã¨ã—ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆåŒ–
      const offsetStart = ev.start.getTime() - dayStartMs;
      const offsetEnd = ev.end.getTime() - dayStartMs;
      const plotStart = new Date(baseStartMs + offsetStart);
      const plotEnd = new Date(baseStartMs + offsetEnd);
      const dataPoint = { x: [plotStart.getTime(), plotEnd.getTime()], y: dayLabel };
      if (ev.label === 'ç¡çœ ') sleepData.push(dataPoint); else awakeData.push(dataPoint);
    }
  }

  // é€±ãƒ»æ—¥ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã¯ seq ã‹ã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆç”Ÿæˆã§å…¨ã¦ã‚«ãƒãƒ¼ã™ã‚‹ãŸã‚ã€
  // è¿½åŠ ã®æŒã¡è¶Šã—/ç¿Œæ—¥å»¶é•·ãƒ­ã‚¸ãƒƒã‚¯ã¯ä¸è¦ã€‚

  const ctx = document.getElementById('timelineChart').getContext('2d');
  if (timelineChart) timelineChart.destroy();

  // å¸¸ã«1é€±é–“è¡¨ç¤ºã«å›ºå®š

  const baseConfig = {
    type: 'bar',
    data: {
      labels: dayLabels,
      datasets: [
        {
          label: 'è¦šé†’ä¸­',
          data: awakeData,
          backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--chart-awake').trim(),
          borderSkipped: false,
          barPercentage: 0.9,
          categoryPercentage: 1.0,
          grouped: false
        },
        {
          label: 'ç¡çœ ä¸­',
          data: sleepData,
          backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--chart-sleep').trim(),
          borderSkipped: false,
          barPercentage: 0.9,
          categoryPercentage: 1.0,
          grouped: false
        }
      ]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      plugins: { legend: { display: true } },
      scales: { x: {} }
    }
  };

  const windowStart = baseStartMs;
  const windowEnd = baseStartMs + 24 * 3600000;
  const timeseriesX = {
    type: 'timeseries',
    time: { unit: 'hour', displayFormats: { hour: 'HH:mm' } },
    min: new Date(windowStart),
    max: new Date(windowEnd)
  };
  const linearX = {
    type: 'linear',
    min: windowStart,
    max: windowEnd,
    ticks: { callback: (value) => formatTime(new Date(value)) }
  };

  try {
    baseConfig.options.scales.x = isDateAdapterReady() ? timeseriesX : linearX;
    timelineChart = new Chart(ctx, baseConfig);
  } catch (err) {
    console.warn('Chart init failed, fallback to linear scale:', err);
    baseConfig.options.scales.x = linearX;
    timelineChart = new Chart(ctx, baseConfig);
  }
}

// ã´ã‚ˆãƒ­ã‚°å–ã‚Šè¾¼ã¿
function handleImportPiyolog() {
  const input = document.getElementById('piyoFile');
  const status = document.getElementById('importStatus');
  if (!input || !input.files || input.files.length === 0) {
    status.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„';
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const text = String(reader.result || '');
      const parsed = parsePiyologTextMulti(text);
      const keys = Object.keys(parsed);
      if (keys.length === 0) {
        status.textContent = 'å–ã‚Šè¾¼ã‚ã‚‹è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ';
        return;
      }
      // å„æ—¥ã‚’ä¸Šæ›¸ãä¿å­˜
      for (const k of keys) {
        const items = parsed[k].filter(l => l && (l.type === 'wake' || l.type === 'nap'));
        allLogs[k] = items;
      }
      saveAllLogs();
      // æœ€çµ‚æ—¥ã®ã‚­ãƒ¼ã«ç§»å‹•
      const latestKey = keys.sort((a, b) => parseDateKey(a) - parseDateKey(b))[keys.length - 1];
      setCurrentDateKey(latestKey);
      status.textContent = `ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†ï¼ˆ${keys.length}æ—¥ / æœ€çµ‚æ—¥: ${latestKey}ï¼‰`;
    } catch (e) {
      console.error(e);
      status.textContent = 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
    }
  };
  reader.onerror = () => {
    status.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
  };
  reader.readAsText(file, 'utf-8');
}

function parsePiyologText(text) {
  const lines = text.split(/\r?\n/);
  const dateHeaderRegex = /^\s*(\d{4})\/(\d{1,2})\/(\d{1,2})\s*\(/;
  const timeLineRegex = /^\s*(\d{2}):(\d{2})\s+(.+)/;

  /** @type {Record<string, Array<{time: string, type: 'wake'|'nap'}>>} */
  const dateToItems = {};
  let currentDateKey = null;

  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const dh = dateHeaderRegex.exec(line);
    if (dh) {
      const y = dh[1].padStart(4, '0');
      const m = dh[2].padStart(2, '0');
      const d = dh[3].padStart(2, '0');
      currentDateKey = `${y}/${m}/${d}`;
      if (!dateToItems[currentDateKey]) dateToItems[currentDateKey] = [];
      continue;
    }
    if (!currentDateKey) continue;
    const tl = timeLineRegex.exec(line);
    if (!tl) continue;
    const hh = tl[1];
    const mm = tl[2];
    const body = tl[3];
    const time = `${hh}:${mm}`;
    let type = null;
    if (body.startsWith('èµ·ãã‚‹')) type = 'wake';
    else if (body.startsWith('å¯ã‚‹')) type = 'nap';
    if (type) {
      dateToItems[currentDateKey].push({ time, type });
    }
  }

  const keys = Object.keys(dateToItems);
  if (keys.length === 0) return { dateKey: null, items: [] };
  const latestKey = keys.sort((a, b) => parseDateKey(a) - parseDateKey(b))[keys.length - 1];
  return { dateKey: latestKey, items: dateToItems[latestKey] };
}

function parseDateKey(key) {
  // key: YYYY/MM/DD
  const [y, m, d] = key.split('/').map(Number);
  const dt = new Date();
  dt.setHours(0, 0, 0, 0);
  dt.setFullYear(y, m - 1, d);
  return dt.getTime();
}

// è¤‡æ•°æ—¥ã‚’è¿”ã™ç‰ˆ
function parsePiyologTextMulti(text) {
  const lines = text.split(/\r?\n/);
  const dateHeaderRegex = /^\s*(\d{4})\/(\d{1,2})\/(\d{1,2})\s*\(/;
  const timeLineRegex = /^\s*(\d{2}):(\d{2})\s+(.+)/;
  /** @type {Record<string, Array<{time: string, type: 'wake'|'nap'}>>} */
  const dateToItems = {};
  let currentDateKey = null;
  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const dh = dateHeaderRegex.exec(line);
    if (dh) {
      const y = dh[1].padStart(4, '0');
      const m = dh[2].padStart(2, '0');
      const d = dh[3].padStart(2, '0');
      currentDateKey = `${y}/${m}/${d}`;
      if (!dateToItems[currentDateKey]) dateToItems[currentDateKey] = [];
      continue;
    }
    if (!currentDateKey) continue;
    const tl = timeLineRegex.exec(line);
    if (!tl) continue;
    const hh = tl[1];
    const mm = tl[2];
    const body = tl[3];
    const time = `${hh}:${mm}`;
    let type = null;
    if (body.startsWith('èµ·ãã‚‹')) type = 'wake';
    else if (body.startsWith('å¯ã‚‹')) type = 'nap';
    if (type) {
      dateToItems[currentDateKey].push({ time, type });
    }
  }
  return dateToItems;
}

// éå»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®äºˆæ¸¬ã‚’å–å¾—ã™ã‚‹é–¢æ•°
function getHistoricalPrediction(currentWakeTime, monthsAge) {
  const allDates = Object.keys(allLogs).sort();
  if (allDates.length < 3) return null; // æœ€ä½3æ—¥åˆ†ã®ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦

  const currentDate = new Date();
  const currentHour = currentWakeTime.getHours();
  
  // éå»30æ—¥åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æ
  const analysisDays = 30;
  const recentDates = allDates.slice(-analysisDays);
  
  let totalAwakeTime = 0;
  let totalNapLength = 0;
  let validPatterns = 0;

  for (const dateKey of recentDates) {
    const dayLogs = allLogs[dateKey] || [];
    if (dayLogs.length < 2) continue;

    // ãã®æ—¥ã®ç¡çœ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æ
    const patterns = analyzeDayPattern(dayLogs, dateKey);
    if (patterns.length === 0) continue;

    // ç¾åœ¨æ™‚åˆ»ã«è¿‘ã„æ™‚é–“å¸¯ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™
    for (const pattern of patterns) {
      if (pattern.wakeHour >= currentHour - 2 && pattern.wakeHour <= currentHour + 2) {
        totalAwakeTime += pattern.awakeTime;
        totalNapLength += pattern.napLength;
        validPatterns++;
      }
    }
  }

  if (validPatterns < 2) return null; // æœ€ä½2ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦

  return {
    avgAwakeTime: totalAwakeTime / validPatterns,
    avgNapLength: totalNapLength / validPatterns,
    dataPoints: validPatterns
  };
}

// 1æ—¥ã®ç¡çœ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æã™ã‚‹é–¢æ•°
function analyzeDayPattern(dayLogs, dateKey) {
  const patterns = [];
  const sortedLogs = dayLogs
    .filter(l => l.type === 'wake' || l.type === 'nap')
    .sort((a, b) => getSortKey(a.time) - getSortKey(b.time));

  for (let i = 0; i < sortedLogs.length - 1; i++) {
    const current = sortedLogs[i];
    const next = sortedLogs[i + 1];
    
    if (current.type === 'wake' && next.type === 'nap') {
      // è¦šé†’â†’ç¡çœ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
      const [wakeHour, wakeMin] = current.time.split(':').map(Number);
      const [napHour, napMin] = next.time.split(':').map(Number);
      
      // è¦šé†’æ™‚é–“ã‚’è¨ˆç®—
      let awakeTime = (napHour * 60 + napMin) - (wakeHour * 60 + wakeMin);
      if (awakeTime < 0) awakeTime += 24 * 60; // æ—¥ã‚’ã¾ãŸãå ´åˆ
      
      // ç¡çœ æ™‚é–“ã‚’è¨ˆç®—ï¼ˆæ¬¡ã®è¦šé†’ã¾ã§ï¼‰
      let napLength = 0;
      if (i + 2 < sortedLogs.length && sortedLogs[i + 2].type === 'wake') {
        const nextWake = sortedLogs[i + 2];
        const [nextWakeHour, nextWakeMin] = nextWake.time.split(':').map(Number);
        napLength = (nextWakeHour * 60 + nextWakeMin) - (napHour * 60 + napMin);
        if (napLength < 0) napLength += 24 * 60;
      } else {
        // æ¬¡ã®è¦šé†’ãŒãªã„å ´åˆã¯æ¨å®š
        napLength = getNapLengthByMonths(null, new Date());
      }

      patterns.push({
        wakeHour: wakeHour,
        awakeTime: awakeTime,
        napLength: napLength,
        date: dateKey
      });
    }
  }

  return patterns;
}

// äºˆæ¸¬ç²¾åº¦ã®è©•ä¾¡ã¨çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
function showPredictionStats() {
  const allDates = Object.keys(allLogs).sort();
  let statsHtml = '';
  
  if (allDates.length < 3) {
    statsHtml = `
      <div class="card">
        <div class="card-header">
          <span class="icon">ğŸ“Š</span>
        <h3>äºˆæ¸¬ç²¾åº¦çµ±è¨ˆ</h3>
        </div>
        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
          <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ“ˆ</div>
          <div>çµ±è¨ˆåˆ†æã«ã¯æœ€ä½3æ—¥åˆ†ã®ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ã§ã™</div>
          <div style="font-size: 0.9rem; margin-top: 0.5rem; color: var(--text-secondary);">ç¾åœ¨ã®è¨˜éŒ²: ${allDates.length}æ—¥åˆ†</div>
        </div>
      </div>
    `;
  } else {
    const stats = calculatePredictionStats();
    statsHtml = `
      <div class="card">
        <div class="card-header">
          <span class="icon">ğŸ“Š</span>
        <h3>äºˆæ¸¬ç²¾åº¦çµ±è¨ˆ</h3>
          </div>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value">${stats.startDate} ã€œ ${stats.endDate}</div>
            <div class="stat-label">ãƒ‡ãƒ¼ã‚¿æœŸé–“ï¼ˆ${stats.totalDays}æ—¥é–“ï¼‰</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${stats.totalLogs}ä»¶</div>
            <div class="stat-label">è¨˜éŒ²ç·æ•°ï¼ˆ1æ—¥å¹³å‡ ${Math.round(stats.avgLogsPerDay)}ä»¶ï¼‰</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${Math.round(stats.avgAwakeTime)}åˆ†</div>
            <div class="stat-label">å¹³å‡è¦šé†’æ™‚é–“ï¼ˆæ¨™æº–åå·®: Â±${Math.round(stats.stdAwakeTime)}åˆ†ï¼‰</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${Math.round(stats.avgNapLength)}åˆ†</div>
            <div class="stat-label">å¹³å‡ç¡çœ æ™‚é–“ï¼ˆæ¨™æº–åå·®: Â±${Math.round(stats.stdNapLength)}åˆ†ï¼‰</div>
        </div>
        </div>
        <div class="pattern-trend-info">
          <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem;">ç¡çœ ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‚¾å‘</div>
          <div style="color: var(--text-secondary);">${stats.patternTrend}</div>
        </div>
      </div>
    `;
  }

  // æ—¢å­˜ã®çµ±è¨ˆè¡¨ç¤ºãŒã‚ã‚Œã°æ›´æ–°ã€ãªã‘ã‚Œã°è¿½åŠ 
  const existingStats = document.getElementById('predictionStats');
  if (existingStats) {
    existingStats.innerHTML = statsHtml;
  } else {
    const container = document.createElement('div');
    container.id = 'predictionStats';
    container.innerHTML = statsHtml;
    document.getElementById('timelineChart').after(container);
  }
}

// äºˆæ¸¬çµ±è¨ˆã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
function calculatePredictionStats() {
  const allDates = Object.keys(allLogs).sort();
  const startDate = allDates[0];
  const endDate = allDates[allDates.length - 1];
  const totalDays = allDates.length;
  
  let totalLogs = 0;
  let totalAwakeTime = 0;
  let totalNapLength = 0;
  let awakeTimes = [];
  let napLengths = [];
  let validPatterns = 0;

  for (const dateKey of allDates) {
    const dayLogs = allLogs[dateKey] || [];
    totalLogs += dayLogs.length;
    
    const patterns = analyzeDayPattern(dayLogs, dateKey);
    for (const pattern of patterns) {
      awakeTimes.push(pattern.awakeTime);
      napLengths.push(pattern.napLength);
      totalAwakeTime += pattern.awakeTime;
      totalNapLength += pattern.napLength;
      validPatterns++;
    }
  }

  const avgAwakeTime = validPatterns > 0 ? totalAwakeTime / validPatterns : 0;
  const avgNapLength = validPatterns > 0 ? totalNapLength / validPatterns : 0;
  
  const stdAwakeTime = calculateStandardDeviation(awakeTimes, avgAwakeTime);
  const stdNapLength = calculateStandardDeviation(napLengths, avgNapLength);

  // ç¡çœ ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‚¾å‘ã‚’åˆ†æ
  const patternTrend = analyzePatternTrend(awakeTimes, napLengths);

  return {
    startDate,
    endDate,
    totalDays,
    totalLogs,
    avgLogsPerDay: totalLogs / totalDays,
    avgAwakeTime,
    avgNapLength,
    stdAwakeTime,
    stdNapLength,
    patternTrend
  };
}

// æ¨™æº–åå·®ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
function calculateStandardDeviation(values, mean) {
  if (values.length < 2) return 0;
  const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
  const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  return Math.sqrt(avgSquaredDiff);
}

// ç¡çœ ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‚¾å‘ã‚’åˆ†æã™ã‚‹é–¢æ•°
function analyzePatternTrend(awakeTimes, napLengths) {
  if (awakeTimes.length < 3) return 'ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã®ãŸã‚å‚¾å‘ã‚’åˆ†æã§ãã¾ã›ã‚“';

  // æ™‚ç³»åˆ—ã§ã®å¤‰åŒ–ã‚’åˆ†æ
  const recentAwake = awakeTimes.slice(-Math.floor(awakeTimes.length / 3));
  const earlyAwake = awakeTimes.slice(0, Math.floor(awakeTimes.length / 3));
  
  const recentAvg = recentAwake.reduce((sum, val) => sum + val, 0) / recentAwake.length;
  const earlyAvg = earlyAwake.reduce((sum, val) => sum + val, 0) / earlyAwake.length;
  
  let trend = '';
  if (recentAvg > earlyAvg + 30) {
    trend = 'è¦šé†’æ™‚é–“ãŒå¾ã€…ã«é•·ããªã£ã¦ã„ã¾ã™';
  } else if (recentAvg < earlyAvg - 30) {
    trend = 'è¦šé†’æ™‚é–“ãŒå¾ã€…ã«çŸ­ããªã£ã¦ã„ã¾ã™';
  } else {
    trend = 'è¦šé†’æ™‚é–“ã¯å®‰å®šã—ã¦ã„ã¾ã™';
  }

  // ç¡çœ æ™‚é–“ã®ä¸€è²«æ€§
  const napStd = calculateStandardDeviation(napLengths, napLengths.reduce((sum, val) => sum + val, 0) / napLengths.length);
  if (napStd < 30) {
    trend += '<br>ç¡çœ æ™‚é–“ã¯ä¸€è²«ã—ã¦ã„ã¾ã™';
  } else if (napStd > 60) {
    trend += '<br>ç¡çœ æ™‚é–“ã«ã°ã‚‰ã¤ããŒã‚ã‚Šã¾ã™';
  } else {
    trend += '<br>ç¡çœ æ™‚é–“ã¯ã‚„ã‚„ã°ã‚‰ã¤ããŒã‚ã‚Šã¾ã™';
  }

  return trend;
}

// ç¡çœ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹é–¢æ•°
function exportSleepData() {
  const allDates = Object.keys(allLogs).sort();
  if (allDates.length === 0) {
    alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
    return;
  }

  let csvContent = 'æ—¥ä»˜,æ™‚åˆ»,ã‚¿ã‚¤ãƒ—\n';
  
  for (const dateKey of allDates) {
    const dayLogs = allLogs[dateKey] || [];
    for (const log of dayLogs) {
      const date = dateKey.replace(/\//g, '-');
      const type = log.type === 'wake' ? 'èµ·åºŠ' : 'ç¡çœ ';
      csvContent += `${date},${log.time},${type}\n`;
    }
  }

  // CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', `baby_sleep_data_${new Date().toISOString().split('T')[0]}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
  const status = document.getElementById('analysisStatus');
  if (status) {
    status.textContent = `ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†ï¼ˆ${allDates.length}æ—¥åˆ†ï¼‰`;
    setTimeout(() => { status.textContent = ''; }, 3000);
  }
}



// æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰detailsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å‰Šé™¤ï¼ˆè©³ç´°è¨˜éŒ²æ©Ÿèƒ½å‰Šé™¤ã®ãŸã‚ï¼‰
function cleanupDetailsField() {
  let hasChanges = false;
  for (const dateKey in allLogs) {
    const dayLogs = allLogs[dateKey] || [];
    for (const log of dayLogs) {
      if (log.details !== undefined) {
        delete log.details;
        hasChanges = true;
      }
    }
  }
  if (hasChanges) {
    saveAllLogs();
  }
}

// åˆæœŸåŒ–
// è¡¨ç¤ºæ—¥åˆæœŸå€¤ã‚’ä»Šæ—¥ã«è¨­å®šã—ã€æ—¥ä»˜å…¥åŠ›ã«ã‚‚åæ˜ 
cleanupDetailsField();
setCurrentDateKey(currentDateKey);
const viewDateEl = document.getElementById('viewDate');
if (viewDateEl) viewDateEl.value = inputValueFromKey(currentDateKey);

// äºˆæ¸¬ç²¾åº¦çµ±è¨ˆã‚’è‡ªå‹•è¡¨ç¤º
showPredictionStats();

// æ™‚åˆ»å…¥åŠ›ã®åˆæœŸå€¤ã‚’ç¾åœ¨æ™‚åˆ»ã«è¨­å®š
const timeInputEl = document.getElementById('timeInput');
if (timeInputEl) {
  timeInputEl.value = nowTimeString();
}

// ç”Ÿå¹´æœˆæ—¥ã®åˆæœŸåŒ–
const birthInputEl = document.getElementById('birthInput');
if (birthInputEl) {
  const saved = localStorage.getItem(BIRTH_KEY);
  if (saved) {
    birthInputEl.value = saved;
    const bd = loadBirth();
    if (bd) {
      document.getElementById('birthStatus').textContent = `ä¿å­˜æ¸ˆã¿ï¼ˆæœˆé½¢: ${calculateMonthsAge(bd)}ãƒ¶æœˆï¼‰`;
    }
  }
  birthInputEl.addEventListener('change', () => {
    // å…¥åŠ›å¤‰æ›´ã§å³ä¿å­˜
    saveBirth(false);
  });
}

// è¡¨ç¤ºæ—¥ã® date å…¥åŠ›å¤‰æ›´ã§åˆ‡æ›¿
const viewDateEl2 = document.getElementById('viewDate');
if (viewDateEl2) {
  viewDateEl2.addEventListener('change', (e) => {
    const v = e.target.value; // YYYY-MM-DD
    if (!v) return;
    const key = v.replace(/-/g, '/');
    setCurrentDateKey(key);
  });
}

// ç¯„å›²ã¯å›ºå®šï¼ˆ1é€±é–“ï¼‰

// ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
function toggleDarkMode() {
  const body = document.body;
  const isDark = body.classList.contains('dark-mode');
  
  if (isDark) {
    // ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
    body.classList.remove('dark-mode');
    localStorage.setItem('darkMode', 'light');
    document.getElementById('darkModeToggle').textContent = 'ğŸŒ™';
    
    // å¼·åˆ¶çš„ã«ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã®è‰²ã‚’é©ç”¨
    document.documentElement.style.setProperty('--background-color', '#f8fafc');
    document.documentElement.style.setProperty('--card-background', '#ffffff');
    document.documentElement.style.setProperty('--text-primary', '#1e293b');
    document.documentElement.style.setProperty('--text-secondary', '#64748b');
    document.documentElement.style.setProperty('--text-muted', '#94a3b8');
    document.documentElement.style.setProperty('--border-color', '#e2e8f0');
  } else {
    // ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
    body.classList.add('dark-mode');
    localStorage.setItem('darkMode', 'dark');
    document.getElementById('darkModeToggle').textContent = 'â˜€ï¸';
    
    // å¼·åˆ¶çš„ã«ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®è‰²ã‚’é©ç”¨
    document.documentElement.style.setProperty('--background-color', '#0f172a');
    document.documentElement.style.setProperty('--card-background', '#1e293b');
    document.documentElement.style.setProperty('--text-primary', '#f1f5f9');
    document.documentElement.style.setProperty('--text-secondary', '#cbd5e1');
    document.documentElement.style.setProperty('--text-muted', '#64748b');
    document.documentElement.style.setProperty('--border-color', '#334155');
  }
  
  // ãƒãƒ£ãƒ¼ãƒˆã®è‰²ã‚’æ›´æ–°
  if (timelineChart) {
    updateTimelineChart();
  }
  
  // å°‘ã—é…å»¶ã•ã›ã¦ã‹ã‚‰ãƒšãƒ¼ã‚¸å…¨ä½“ã‚’å†æç”»
  setTimeout(() => {
    // ãƒ•ã‚©ãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è‰²ã‚’å¼·åˆ¶æ›´æ–°
    const formControls = document.querySelectorAll('.form-control');
    formControls.forEach(control => {
      if (isDark) {
        control.style.background = '#ffffff';
        control.style.color = '#1e293b';
      } else {
        control.style.background = '#1e293b';
        control.style.color = '#f1f5f9';
      }
    });
  }, 100);
}

// ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®åˆæœŸåŒ–
function initDarkMode() {
  const savedMode = localStorage.getItem('darkMode');
  
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«è¨­å®šã—ãŸå ´åˆã¯ã€ãã®è¨­å®šã‚’å„ªå…ˆ
  if (savedMode === 'dark') {
    document.body.classList.add('dark-mode');
    document.getElementById('darkModeToggle').textContent = 'â˜€ï¸';
    
    // å¼·åˆ¶çš„ã«ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®è‰²ã‚’é©ç”¨
    document.documentElement.style.setProperty('--background-color', '#0f172a');
    document.documentElement.style.setProperty('--card-background', '#1e293b');
    document.documentElement.style.setProperty('--text-primary', '#f1f5f9');
    document.documentElement.style.setProperty('--text-secondary', '#cbd5e1');
    document.documentElement.style.setProperty('--text-muted', '#64748b');
    document.documentElement.style.setProperty('--border-color', '#334155');
  } else if (savedMode === 'light') {
    document.body.classList.remove('dark-mode');
    document.getElementById('darkModeToggle').textContent = 'ğŸŒ™';
    
    // å¼·åˆ¶çš„ã«ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã®è‰²ã‚’é©ç”¨
    document.documentElement.style.setProperty('--background-color', '#f8fafc');
    document.documentElement.style.setProperty('--card-background', '#ffffff');
    document.documentElement.style.setProperty('--text-primary', '#1e293b');
    document.documentElement.style.setProperty('--text-secondary', '#64748b');
    document.documentElement.style.setProperty('--text-muted', '#94a3b8');
    document.documentElement.style.setProperty('--border-color', '#e2e8f0');
  } else {
    // åˆå›ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã®ã¿ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ä½¿ç”¨
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (prefersDark) {
      document.body.classList.add('dark-mode');
      document.getElementById('darkModeToggle').textContent = 'â˜€ï¸';
      localStorage.setItem('darkMode', 'dark');
      
      // å¼·åˆ¶çš„ã«ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®è‰²ã‚’é©ç”¨
      document.documentElement.style.setProperty('--background-color', '#0f172a');
      document.documentElement.style.setProperty('--card-background', '#1e293b');
      document.documentElement.style.setProperty('--text-primary', '#f1f5f9');
      document.documentElement.style.setProperty('--text-secondary', '#cbd5e1');
      document.documentElement.style.setProperty('--text-muted', '#64748b');
      document.documentElement.style.setProperty('--border-color', '#334155');
    } else {
      localStorage.setItem('darkMode', 'light');
    }
  }
}

// ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šå¤‰æ›´ã‚’ç›£è¦–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¨­å®šã—ã¦ã„ãªã„å ´åˆã®ã¿ï¼‰
function watchSystemTheme() {
  const savedMode = localStorage.getItem('darkMode');
  
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«è¨­å®šã—ã¦ã„ãªã„å ´åˆã®ã¿ç›£è¦–
  if (!savedMode) {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    mediaQuery.addEventListener('change', (e) => {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã¾ã è¨­å®šã—ã¦ã„ãªã„å ´åˆã®ã¿è‡ªå‹•å¤‰æ›´
      if (!localStorage.getItem('darkMode')) {
        if (e.matches) {
          document.body.classList.add('dark-mode');
          document.getElementById('darkModeToggle').textContent = 'â˜€ï¸';
          localStorage.setItem('darkMode', 'dark');
        } else {
          document.body.classList.remove('dark-mode');
          document.getElementById('darkModeToggle').textContent = 'ğŸŒ™';
          localStorage.setItem('darkMode', 'light');
        }
        
        // ãƒãƒ£ãƒ¼ãƒˆã®è‰²ã‚’æ›´æ–°
        if (timelineChart) {
          updateTimelineChart();
        }
      }
    });
  }
}

// ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
document.addEventListener('DOMContentLoaded', () => {
  const darkModeToggle = document.getElementById('darkModeToggle');
  if (darkModeToggle) {
    darkModeToggle.addEventListener('click', toggleDarkMode);
  }
  
  // åˆæœŸåŒ–
  initDarkMode();
  
  // ã‚·ã‚¹ãƒ†ãƒ ãƒ†ãƒ¼ãƒã®ç›£è¦–ã‚’é–‹å§‹
  watchSystemTheme();
});
</script>

<script>
// PWA Service Workerç™»éŒ²
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js');
}
</script>

</body>
</html>
